<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-10-26T16:27:33+08:00</updated><id>/feed.xml</id><title type="html">The Lost Fridge’s blog</title><subtitle>The blogs inside the fridge (mostly harmless) lost in the space.</subtitle><entry><title type="html">[unity] 实现大地形渲染之 geometry clipmap</title><link href="/unity/2022/03/07/geoclipmap.html" rel="alternate" type="text/html" title="[unity] 实现大地形渲染之 geometry clipmap" /><published>2022-03-07T00:41:00+08:00</published><updated>2022-03-07T00:41:00+08:00</updated><id>/unity/2022/03/07/geoclipmap</id><content type="html" xml:base="/unity/2022/03/07/geoclipmap.html"><![CDATA[<p data-first-child="" data-pid="gz5zWSbi">最近希望在unity中实现一个简单的geometry clipmap，用于飞行模拟游戏中巨大地形的渲染。但是网上冲浪之后发现资料有点少，只好一点点从头做起。那么就用本文记录一些个人比较迷惑的地方，作为我的备忘录和经验分享吧。</p>

<p data-pid="t3Ir7lca">目前没有完全实现，但是看了下效果确实有点差，不加其他功能的话基本用不了。虽然没有做过性能测试，但是感觉很多为了效率做的细节其实没必要完全照着论文去做，有些在unity也不好实现。最近看到了这个视频：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1au411y7Fq%3Fspm_id_from%3D333.999.0.0" class=" wrap external" target="_blank" rel="nofollow noreferrer">06.游戏中地形大气和云的渲染(上) | GAMES104-现代游戏引擎：从入门到实践_哔哩哔哩_bilibili</a>，发现geometry clipmap其实最有指导意义的就是：</p>

<ul>
<li data-pid="Xic5Z26N">分层LOD+相机坐标系渲染（我最开始想解决的问题）</li>
<li data-pid="k4eV76YG">资源流式加载（原始论文其实没怎么提，不过从贴图的循环更新ToroidalOrigin能看出来）</li>
</ul>

<p data-pid="M-PA-uml">看完视频暂时不想搞这个闭门造车了，查查virtual texture去，这样就不用自己做流式加载啦：）。</p>

<p data-pid="LIYwd8rA">参考资料：<a href="https://link.zhihu.com/?target=https%3A//developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-2-terrain-rendering-using-gpu-based-geometry" class=" wrap external" target="_blank" rel="nofollow noreferrer">GPU Gems 2</a>, <a href="https://link.zhihu.com/?target=https%3A//hhoppe.com/geomclipmap.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">geometry clipmap 原始论文</a></p>

<h2 data-into-catalog-status="">算法整体框架</h2>

<p><img src="https://pic4.zhimg.com/80/v2-558d471d61a73ab92c836ac89bfcd803_720w.jpg" data-size="normal" data-rawwidth="1330" data-rawheight="354" class="origin_image zh-lightbox-thumb lazy" width="1330" data-original="https://pic4.zhimg.com/v2-558d471d61a73ab92c836ac89bfcd803_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-558d471d61a73ab92c836ac89bfcd803_b.jpg" /></p>
<p data-pid="Mz-CBUzn">从论文中可以清晰得知，算法需要三个步骤：计算active region（我们希望渲染的地形范围）；更新geometry clipmap（多级地形纹理/贴图）；裁剪渲染范围至贴图范围，并进行渲染。</p>

<h2 data-into-catalog-status="">代码解读</h2>

<h3 data-into-catalog-status="">Upsample（上采样）</h3>

<p data-pid="zwNq6p6-">算法通过对较粗糙的高度图纹理进行插值来获取分辨率更高（一级）的高度图。</p>

<p data-pid="MUcgADSU">不过在gpu gems提供的示例代码中，为了实现不同类型坐标的插值计算，这个算法写的比较绕，它的pixel shader是这样的：</p>

<div><pre><code class="language-glsl"><span class="n">float4</span> <span class="n">UpsamplePS</span><span class="p">(</span><span class="n">float2</span> <span class="n">p_uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">residual</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">ResidualSampler</span><span class="p">,</span> <span class="n">p_uv</span><span class="o">*</span><span class="n">OneOverSize</span><span class="p">);</span>  
    
    <span class="n">p_uv</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">p_uv</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">p_uv_div2</span> <span class="o">=</span> <span class="n">p_uv</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">lookup_tij</span> <span class="o">=</span> <span class="n">p_uv_div2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> 
    <span class="n">float4</span> <span class="n">maskType</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">LookupSampler</span><span class="p">,</span> <span class="n">lookup_tij</span><span class="p">);</span>     
          
    <span class="n">matrix</span> <span class="n">maskMatrix</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">maskMatrix</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">);</span>
                           
    <span class="n">maskMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span>
                           <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">81.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">81.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">);</span>                        
                           
    <span class="n">maskMatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">81.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">81.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">);</span>
                           
    <span class="n">maskMatrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">16.0</span><span class="n">f</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span>
                           <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="mf">256.0</span><span class="n">f</span><span class="p">);</span>

    <span class="n">float2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">maskType</span><span class="p">.</span><span class="n">bgra</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)),</span> <span class="n">dot</span><span class="p">(</span><span class="n">maskType</span><span class="p">.</span><span class="n">bgra</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)));</span>
    
    <span class="k">float</span> <span class="n">z_predicted</span><span class="o">=</span><span class="mo">0</span><span class="p">;</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_uv_div2</span><span class="o">-</span><span class="n">offset</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">OneOverSize</span><span class="o">+</span><span class="n">TextureOffset</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">float</span> <span class="n">zrowv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">float2</span> <span class="n">vij</span>    <span class="o">=</span> <span class="n">offset</span><span class="o">+</span><span class="n">float2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">OneOverSize</span><span class="p">;</span>
                <span class="n">zrowv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>      <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">CoarseLevelElevationSampler</span><span class="p">,</span> <span class="n">vij</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">vector</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">maskType</span><span class="p">.</span><span class="n">bgra</span><span class="p">,</span> <span class="n">maskMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">vector</span> <span class="n">zrow</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">zrowv</span><span class="p">[</span><span class="mo">0</span><span class="p">],</span> <span class="n">zrowv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zrowv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">zrowv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
        <span class="n">zrow</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">zrow</span><span class="p">);</span>
        <span class="n">z_predicted</span> <span class="o">=</span> <span class="n">z_predicted</span><span class="o">+</span><span class="n">dot</span><span class="p">(</span><span class="n">zrow</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>

    
    <span class="n">z_predicted</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">z_predicted</span><span class="p">);</span>
    
    <span class="c1">// add the residual to get the actual elevation</span>
    <span class="k">float</span> <span class="n">zf</span> <span class="o">=</span> <span class="n">z_predicted</span> <span class="o">+</span> <span class="n">residual</span><span class="p">;</span>  
    
    <span class="c1">// zf should always be an integer, since it gets packed</span>
    <span class="c1">//  into the integer component of the floating-point texture</span>
    <span class="n">zf</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">zf</span><span class="p">);</span>
    
    <span class="n">float4</span> <span class="n">uvc</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">float4</span><span class="p">((</span><span class="n">p_uv_div2</span><span class="o">+</span><span class="n">float2</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span><span class="mo">0</span><span class="p">)),</span> 
                              <span class="p">(</span><span class="n">p_uv_div2</span><span class="o">+</span><span class="n">float2</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="mf">0.5</span><span class="n">f</span><span class="p">))))</span><span class="o">*</span><span class="n">OneOverSize</span><span class="o">+</span><span class="n">TextureOffset</span><span class="p">.</span><span class="n">xyxy</span><span class="p">;</span> 
            
    <span class="c1">// look up the z_predicted value in the coarser levels  </span>
    <span class="k">float</span> <span class="n">zc0</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">CoarseLevelElevationSampler</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">uvc</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="k">float</span> <span class="n">zc1</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">CoarseLevelElevationSampler</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">uvc</span><span class="p">.</span><span class="n">zw</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>        
    
    <span class="k">float</span> <span class="n">zf_zd</span> <span class="o">=</span> <span class="n">zf</span> <span class="o">+</span> <span class="p">((</span><span class="n">zc0</span><span class="o">+</span><span class="n">zc1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">zf</span><span class="o">+</span><span class="mi">256</span><span class="p">)</span><span class="o">/</span><span class="mi">512</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">zf_zd</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p data-pid="ONtnu2LN">这个LookupSampler（texture）和maskMatrix比较魔法，在此分析一下。</p>

<p data-pid="KKQ1SCHD">我们在上采样时要从粗糙lv0的高度图（方框）插值计算出更精确一级lv1的高度图（圆圈），它们之间的关系如图所示。为了方便起见，假设我们的uv坐标是一个单位对应一像素（注意在lv0中坐标细分为0.5），那么lv1在lv0中的坐标有4种类型：</p>

<ul>
<li data-pid="lm4di3En">和上一级重合：（0，0）</li>
<li data-pid="r-mdpnen">在两个像素中央：（0，0.5)，（0.5，0）</li>
<li data-pid="_0d1vGNV">在四个像素中央：（0.5，0.5）</li>
</ul>

<p><img src="https://pic1.zhimg.com/80/v2-e753702f87c0fc161b4e80cbfebe0c98_720w.jpg" data-size="normal" data-rawwidth="304" data-rawheight="296" class="content_image lazy" width="304" data-actualsrc="https://pic1.zhimg.com/v2-e753702f87c0fc161b4e80cbfebe0c98_b.jpg" /></p>
<p data-pid="iW4d3pzQ">那么通过权重为（-1/16, 9/16, 9/16, -1/16）的四点法插值</p>

<p><img src="https://pic2.zhimg.com/80/v2-0384a7d0d9f01c56508be8aa66bf1a45_720w.jpg" data-size="normal" data-rawwidth="1158" data-rawheight="94" class="origin_image zh-lightbox-thumb lazy" width="1158" data-original="https://pic2.zhimg.com/v2-0384a7d0d9f01c56508be8aa66bf1a45_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0384a7d0d9f01c56508be8aa66bf1a45_b.jpg" /></p>
<p data-pid="xS2NGvES">这四种类型的坐标的计算方式分别需要1、4、4、16个点的数据，如下图不同颜色的方框所示。</p>

<p><img src="https://pic4.zhimg.com/80/v2-56ad3b01215be01dca703f76d70529cb_720w.jpg" data-size="normal" data-rawwidth="304" data-rawheight="296" class="content_image lazy" width="304" data-actualsrc="https://pic4.zhimg.com/v2-56ad3b01215be01dca703f76d70529cb_b.jpg" /></p>
<p data-pid="qNQkcmwp">比较直观的插值公式如右侧的矩阵所示，直接对最大范围的16点数据与权重（方便起见省去了分母 /256）进行点乘即可。但是因为gpu不便处理分支语句，gpu gems里使用循环+额外的一张2*2控制纹理来实现算法，这些权重矩阵则被拆散进了maskMatrix中（如左侧所示）。比如右侧矩阵1的第一行在左侧矩阵4的第一行（这里为了和图片对应，行坐标颠倒了），而其第二行则在左侧矩阵3的第一行，第三行在左侧矩阵2的第一行......依次类推。控制纹理中则简单地记录了4个one-hot向量：</p>

<p data-pid="Wx24FgM-"><b>后来我发现这里好像搞反了行坐标和列坐标，不过大概意思大家能看懂就行了</b></p>

<ul>
<li data-pid="q4bJfpDT">(1,0,0,0)：对应坐标类型（0，0）</li>
<li data-pid="kJHF7xaa">(0,1,0,0)：对应坐标类型（0，0.5）</li>
<li data-pid="lQVi97Ob">(0,0,1,0)：对应坐标类型（0.5， 0）</li>
<li data-pid="GhS9DDHw">(0,0,0,1)：对应坐标类型（0.5，0.5）</li>
</ul>

<p><img src="https://pic4.zhimg.com/80/v2-b50f7aef8c841895f57311412b386e1b_720w.jpg" data-size="normal" data-rawwidth="1235" data-rawheight="717" class="origin_image zh-lightbox-thumb lazy" width="1235" data-original="https://pic4.zhimg.com/v2-b50f7aef8c841895f57311412b386e1b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-b50f7aef8c841895f57311412b386e1b_b.jpg" /></p>
<p data-pid="3AVEOQ0g">另外两个shader，ComputeNormal（法线计算）和 Render（渲染）相对比较简单，没有什么需要专门分析的地方，看gpu gems基本就行了。</p>

<h3 data-into-catalog-status="">分级网格</h3>

<p data-pid="iq1mDui0">原始论文中对网格的的实现搞了很多花活，其实我不太懂，大部分情况应该都是为了节省顶点的开销，尽量复用子结构。比较重要的点应该在于网格并不是正好一级级“嵌套”起来的，层级之间存在一小片可以调整的区域，这样内层网格可以随着地图加载中心点的变化进行一点点平移，而外层则不用移动。需要注意为了防止插值造成的波浪状效果，mesh网格是“吸附”到地图坐标网格上的，也就是说纹理贴图只能进行一格格的平移，正好也对应了这个调整范围。</p>

<p data-pid="RbKIFtKP">我在测试的时候直接奢侈一把，网格全部老老实实画出来完事，不做顶点复用。这里输出一下边缘过渡区的alpha值来展示一下分级的网格结构：</p>

<p><img src="https://pic3.zhimg.com/80/v2-cc93f14413be7c2d1cb0c346e54f32d6_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1539" data-rawheight="776" class="origin_image zh-lightbox-thumb lazy" width="1539" data-original="https://pic3.zhimg.com/v2-cc93f14413be7c2d1cb0c346e54f32d6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-cc93f14413be7c2d1cb0c346e54f32d6_b.jpg" /></p>
<h3 data-into-catalog-status="">流式加载</h3>

<p data-pid="6v40jOT7">咕了</p>

<h2 data-into-catalog-status="">一些改动</h2>

<h3 data-into-catalog-status="">Occlusion（遮挡）</h3>

<p data-pid="ltKSqnU7">gpu gems提供的代码仅用法线计算光照强度（Lambertian reflectance），已经可以获得非常明显的明暗效果，让地形有了立体感；但是在起伏的山丘地形上，明显能发现怪怪的，是因为没有临近地形的遮挡效果。考虑单个平行光源（太阳）的情况，在每一个位置，我们可以根据光线方向作一条射线判断是否与地形相交来确定该位置是否会被遮挡，计算出额外的一张遮挡贴图，在最终的render里与输出相乘，类似这样就可以了：</p>

<div><pre><code class="language-glsl"><span class="n">OUTPUT</span> <span class="n">OcclusionVS</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">OUTPUT</span> <span class="k">output</span><span class="p">;</span>
    <span class="k">output</span><span class="p">.</span><span class="n">position</span>   <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
    <span class="k">output</span><span class="p">.</span><span class="n">position</span>   <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="k">output</span><span class="p">.</span><span class="n">texcoords</span>  <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="o">*</span><span class="n">Size</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="k">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float4</span> <span class="n">OcclusionPS</span><span class="p">(</span><span class="n">OUTPUT</span> <span class="k">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">p_uv_div2</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="k">input</span><span class="p">.</span><span class="n">texcoords</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="n">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_uv_div2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">OneOverSize</span> <span class="o">+</span> <span class="n">TextureOffset</span><span class="p">;</span>
    <span class="k">float</span> <span class="n">height</span> <span class="o">=</span> <span class="n">coarseHeight</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">linear_repeat_sampler</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>

    <span class="k">float</span> <span class="n">occlusion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">float</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
        <span class="n">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_uv_div2</span> <span class="o">+</span> <span class="n">dis</span> <span class="o">*</span> <span class="n">LightDirection</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">OneOverSize</span> <span class="o">+</span> <span class="n">TextureOffset</span><span class="p">;</span>
        <span class="k">float</span> <span class="n">h</span> <span class="o">=</span> <span class="n">coarseHeight</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">linear_repeat_sampler</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>
        <span class="n">occlusion</span> <span class="o">+=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="n">dis</span> <span class="o">*</span> <span class="n">ScaleFac</span> <span class="o">-</span> <span class="n">h</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mo">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">clamp</span><span class="p">(</span><span class="n">occlusion</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mo">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p><img src="https://pic1.zhimg.com/80/v2-de10cbb49c06ab973e01160643ae7ae8_720w.jpg" data-size="normal" data-rawwidth="1550" data-rawheight="782" class="origin_image zh-lightbox-thumb lazy" width="1550" data-original="https://pic1.zhimg.com/v2-de10cbb49c06ab973e01160643ae7ae8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-de10cbb49c06ab973e01160643ae7ae8_b.jpg" />
<img src="https://pic1.zhimg.com/80/v2-30e83db10aef9270644cefeba99e22e4_720w.jpg" data-size="normal" data-rawwidth="1417" data-rawheight="527" class="origin_image zh-lightbox-thumb lazy" width="1417" data-original="https://pic1.zhimg.com/v2-30e83db10aef9270644cefeba99e22e4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-30e83db10aef9270644cefeba99e22e4_b.jpg" /></p>
<h2 data-into-catalog-status="">调试中遇到的问题</h2>

<p data-pid="M24h7EGe">因为基本没怎么写过shader，中间碰到了一些问题解决了好久。一个碰到好多次的问题就是，纹理中会出现一些横竖的条纹，这个原因99%就是采样的问题。第一次是因为没有关闭纹理的mipmap，而我的贴图又是一个长方形的尺寸，导致短边上被开启了降采样，出现了好多暗纹。第二次是因为纹理使用了“点采样”，也就是不进行插值，但是在计算uv坐标的时候使用了a+b的形式，其中b是能刚好落在贴图网格上的，但是a忘了做好取整的操作，导致某些地方的采样点重合了，出现了横竖的条纹。</p>]]></content><author><name></name></author><category term="unity" /><summary type="html"><![CDATA[最近希望在unity中实现一个简单的geometry clipmap，用于飞行模拟游戏中巨大地形的渲染。但是网上冲浪之后发现资料有点少，只好一点点从头做起。那么就用本文记录一些个人比较迷惑的地方，作为我的备忘录和经验分享吧。 目前没有完全实现，但是看了下效果确实有点差，不加其他功能的话基本用不了。虽然没有做过性能测试，但是感觉很多为了效率做的细节其实没必要完全照着论文去做，有些在unity也不好实现。最近看到了这个视频：06.游戏中地形大气和云的渲染(上) | GAMES104-现代游戏引擎：从入门到实践_哔哩哔哩_bilibili，发现geometry clipmap其实最有指导意义的就是： 分层LOD+相机坐标系渲染（我最开始想解决的问题） 资源流式加载（原始论文其实没怎么提，不过从贴图的循环更新ToroidalOrigin能看出来） 看完视频暂时不想搞这个闭门造车了，查查virtual texture去，这样就不用自己做流式加载啦：）。 参考资料：GPU Gems 2, geometry clipmap 原始论文 算法整体框架 从论文中可以清晰得知，算法需要三个步骤：计算active region（我们希望渲染的地形范围）；更新geometry clipmap（多级地形纹理/贴图）；裁剪渲染范围至贴图范围，并进行渲染。 代码解读 Upsample（上采样） 算法通过对较粗糙的高度图纹理进行插值来获取分辨率更高（一级）的高度图。 不过在gpu gems提供的示例代码中，为了实现不同类型坐标的插值计算，这个算法写的比较绕，它的pixel shader是这样的： float4 UpsamplePS(float2 p_uv : TEXCOORD0) : COLOR { float residual = tex2D(ResidualSampler, p_uv*OneOverSize); p_uv = floor(p_uv); float2 p_uv_div2 = p_uv/2; float2 lookup_tij = p_uv_div2+1; float4 maskType = tex2D(LookupSampler, lookup_tij); matrix maskMatrix[4]; maskMatrix[0] = matrix(0, 0, 0, 0, 0, -1.0f/16.0f, 0, 0, 0, 0, 0, 0, 1.0f/256.0f, -9.0f/256.0f, -9.0f/256.0f, 1.0f/256.0f); maskMatrix[1] = matrix(0, 1, 0, 0, 0, 9.0f/16.0f, 0, 0, -1.0f/16.0f, 9.0f/16.0f, 9.0f/16.0f, -1.0f/16.0f, -9.0f/256.0f, 81.0f/256.0f, 81.0f/256.0f, -9.0f/256.0f); maskMatrix[2] = matrix(0, 0, 0, 0, 0, 9.0f/16.0f, 0, 0, 0, 0, 0, 0, -9.0f/256.0f, 81.0f/256.0f, 81.0f/256.0f, -9.0f/256.0f); maskMatrix[3] = matrix(0, 0, 0, 0, 0, -1.0f/16.0f, 0, 0, 0, 0, 0, 0, 1.0f/256.0f, -9.0f/256.0f, -9.0f/256.0f, 1.0f/256.0f); float2 offset = float2(dot(maskType.bgra, float4(1, 1.5, 1, 1.5)), dot(maskType.bgra, float4(1, 1, 1.5, 1.5))); float z_predicted=0; offset = (p_uv_div2-offset+0.5)*OneOverSize+TextureOffset; for(int i = 0; i &lt; 4; i++) { float zrowv[4]; for (int j = 0; j &lt; 4; j++) { float2 vij = offset+float2(i,j)*OneOverSize; zrowv[j] = tex2D(CoarseLevelElevationSampler, vij); } vector mask = mul(maskType.bgra, maskMatrix[i]); vector zrow = vector(zrowv[0], zrowv[1], zrowv[2], zrowv[3]); zrow = floor(zrow); z_predicted = z_predicted+dot(zrow, mask); } z_predicted = floor(z_predicted); // add the residual to get the actual elevation float zf = z_predicted + residual; // zf should always be an integer, since it gets packed // into the integer component of the floating-point texture zf = floor(zf); float4 uvc = floor(float4((p_uv_div2+float2(0.5f,0)), (p_uv_div2+float2(0,0.5f))))*OneOverSize+TextureOffset.xyxy; // look up the z_predicted value in the coarser levels float zc0 = floor(tex2D(CoarseLevelElevationSampler, float4(uvc.xy, 0, 1))); float zc1 = floor(tex2D(CoarseLevelElevationSampler, float4(uvc.zw, 0, 1))); float zf_zd = zf + ((zc0+zc1)/2-zf+256)/512; return float4(zf_zd, 0, 0, 0); } 这个LookupSampler（texture）和maskMatrix比较魔法，在此分析一下。 我们在上采样时要从粗糙lv0的高度图（方框）插值计算出更精确一级lv1的高度图（圆圈），它们之间的关系如图所示。为了方便起见，假设我们的uv坐标是一个单位对应一像素（注意在lv0中坐标细分为0.5），那么lv1在lv0中的坐标有4种类型： 和上一级重合：（0，0） 在两个像素中央：（0，0.5)，（0.5，0） 在四个像素中央：（0.5，0.5） 那么通过权重为（-1/16, 9/16, 9/16, -1/16）的四点法插值 这四种类型的坐标的计算方式分别需要1、4、4、16个点的数据，如下图不同颜色的方框所示。 比较直观的插值公式如右侧的矩阵所示，直接对最大范围的16点数据与权重（方便起见省去了分母 /256）进行点乘即可。但是因为gpu不便处理分支语句，gpu gems里使用循环+额外的一张2*2控制纹理来实现算法，这些权重矩阵则被拆散进了maskMatrix中（如左侧所示）。比如右侧矩阵1的第一行在左侧矩阵4的第一行（这里为了和图片对应，行坐标颠倒了），而其第二行则在左侧矩阵3的第一行，第三行在左侧矩阵2的第一行......依次类推。控制纹理中则简单地记录了4个one-hot向量： 后来我发现这里好像搞反了行坐标和列坐标，不过大概意思大家能看懂就行了 (1,0,0,0)：对应坐标类型（0，0） (0,1,0,0)：对应坐标类型（0，0.5） (0,0,1,0)：对应坐标类型（0.5， 0） (0,0,0,1)：对应坐标类型（0.5，0.5） 另外两个shader，ComputeNormal（法线计算）和 Render（渲染）相对比较简单，没有什么需要专门分析的地方，看gpu gems基本就行了。 分级网格 原始论文中对网格的的实现搞了很多花活，其实我不太懂，大部分情况应该都是为了节省顶点的开销，尽量复用子结构。比较重要的点应该在于网格并不是正好一级级“嵌套”起来的，层级之间存在一小片可以调整的区域，这样内层网格可以随着地图加载中心点的变化进行一点点平移，而外层则不用移动。需要注意为了防止插值造成的波浪状效果，mesh网格是“吸附”到地图坐标网格上的，也就是说纹理贴图只能进行一格格的平移，正好也对应了这个调整范围。 我在测试的时候直接奢侈一把，网格全部老老实实画出来完事，不做顶点复用。这里输出一下边缘过渡区的alpha值来展示一下分级的网格结构： 流式加载 咕了 一些改动 Occlusion（遮挡） gpu gems提供的代码仅用法线计算光照强度（Lambertian reflectance），已经可以获得非常明显的明暗效果，让地形有了立体感；但是在起伏的山丘地形上，明显能发现怪怪的，是因为没有临近地形的遮挡效果。考虑单个平行光源（太阳）的情况，在每一个位置，我们可以根据光线方向作一条射线判断是否与地形相交来确定该位置是否会被遮挡，计算出额外的一张遮挡贴图，在最终的render里与输出相乘，类似这样就可以了： OUTPUT OcclusionVS(appdata v) { OUTPUT output; output.position = float4(float2(v.vertex.x,v.vertex.y),0.0,1.0); output.position = UnityObjectToClipPos(v.vertex); output.texcoords = v.uv*Size; return output; } float4 OcclusionPS(OUTPUT input) : SV_Target { float2 p_uv_div2 = floor(input.texcoords)/2; float2 uv = (p_uv_div2 + 0.5)*OneOverSize + TextureOffset; float height = coarseHeight.Sample(linear_repeat_sampler, uv).x; float occlusion = 1; for(int i = 1; i &lt; 30; i++) { float dis = i / 2.0; float2 uv = (p_uv_div2 + dis * LightDirection + 0.5)*OneOverSize + TextureOffset; float h = coarseHeight.Sample(linear_repeat_sampler, uv).x; occlusion += clamp(sign(height + dis * ScaleFac - h), -1, 0) * 0.2; } return float4(clamp(occlusion, 0, 1), 0, 0, 0); } 调试中遇到的问题 因为基本没怎么写过shader，中间碰到了一些问题解决了好久。一个碰到好多次的问题就是，纹理中会出现一些横竖的条纹，这个原因99%就是采样的问题。第一次是因为没有关闭纹理的mipmap，而我的贴图又是一个长方形的尺寸，导致短边上被开启了降采样，出现了好多暗纹。第二次是因为纹理使用了“点采样”，也就是不进行插值，但是在计算uv坐标的时候使用了a+b的形式，其中b是能刚好落在贴图网格上的，但是a忘了做好取整的操作，导致某些地方的采样点重合了，出现了横竖的条纹。]]></summary></entry><entry><title type="html">[unity] 仿造一个枭龙战机的HUD</title><link href="/unity/2022/02/02/jf17-hud.html" rel="alternate" type="text/html" title="[unity] 仿造一个枭龙战机的HUD" /><published>2022-02-02T21:38:00+08:00</published><updated>2022-02-02T21:38:00+08:00</updated><id>/unity/2022/02/02/jf17-hud</id><content type="html" xml:base="/unity/2022/02/02/jf17-hud.html"><![CDATA[<p data-first-child="" data-pid="_YZfbYq6">我希望在自制的游戏中实现一个简单的HUD（<i>Head-up display 抬头显示器</i>），使其看起来“像那么回事”；DCS游戏中的座舱制作的算比较精致的，鉴于财力问题，我们这次能够“抄作业“的最好对象就是JF-17”枭龙“战机的HUD了：</p>

<p><img src="https://pic2.zhimg.com/80/v2-2abf2d4306fdaf236d927a9b9a2a55d9_720w.jpg" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-2abf2d4306fdaf236d927a9b9a2a55d9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2abf2d4306fdaf236d927a9b9a2a55d9_b.jpg" /></p>
<p data-pid="t_Qquo-w">枭龙模组的HUD非常复杂，我们本次尝试只选择实现这些内容：</p>

<ul>
<li data-pid="T6exWgMK">反射式成像的效果：图像中心的光线始终与载机轴线平行，看起来始终保持在正前方；图像看起来在无限远处，成像大小仅和视角有关，前后移动，并不会有近大远小的效果</li>
<li data-pid="-B6KPM4q">速度、高度、航向指示器，且刻度有滚动效果</li>
<li data-pid="1ejycJ1H">姿态仪，能够正确显示俯仰、偏航、滚转角度</li>
<li data-pid="Uc_Lxn5Z">速度矢量符号、机头指向</li>
<li data-pid="mu3XMxZQ">其他纯文字内容：攻角、过载、历史最大过载、马赫数、HUD模式等</li>
</ul>

<p><img src="https://pic4.zhimg.com/80/v2-25983cccb55965a79492b94f1a2fd7f3_b.gif" data-size="normal" data-rawwidth="300" data-rawheight="259" data-thumbnail="https://pic4.zhimg.com/v2-25983cccb55965a79492b94f1a2fd7f3_b.jpg" class="content_image lazy" width="300" data-actualsrc="https://pic4.zhimg.com/v2-25983cccb55965a79492b94f1a2fd7f3_b.gif" /></p>
<h3 data-into-catalog-status="">贴图绘制</h3>

<p data-pid="vgvIYfGR">实现HUD的整体思路是将其中动态的部分拆解成独立的图片，来进行移动、旋转操作。通过一些取巧的手段，本次实现的内容都不需要动态生成mesh就能够完成，这样工作量就少了很多。</p>

<p data-pid="-6E-WALp">HUD中的图像除了文字就是一些线条，虽然不太复杂但是对位置的精准性要求比较高，所以我使用了手写svg的方式来绘制HUD。这种方法后续调整参数比较方便，同时不需要专业的软件，直接用文本编辑器就可以了。我构造了一个简单的工作流：首先写出要绘制内容的jinja2模板，然后通过python脚本填入参数生成.svg文件，再使用inkscape将其渲染为.png文件。</p>

<p data-pid="_VoAl4tt">以左侧的速度表的滚动刻度为例，它的jinja2模板长这个样子：</p>

<div><pre><code class="language-django"><span class="x">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</span><span class="x"></span><span class="cp">{%</span> <span class="k">set</span> <span class="nv">height</span> <span class="o">=</span> <span class="nv">scale_height</span> <span class="o">*</span> <span class="o">(</span><span class="nv">scales</span><span class="o">|</span><span class="nf">length</span> <span class="o">*</span> <span class="nv">line_widths</span><span class="o">|</span><span class="nf">length</span><span class="o">)</span> <span class="cp">%}</span><span class="x">
</span><span class="x"></span><span class="cp">{%</span> <span class="k">set</span> <span class="nv">x_mid</span> <span class="o">=</span> <span class="nv">width</span><span class="o">/</span><span class="m">2</span> <span class="cp">%}</span><span class="x">
</span><span class="x"></span><span class="cp">{%</span> <span class="k">set</span> <span class="nv">y_mid</span> <span class="o">=</span> <span class="nv">height</span> <span class="cp">%}</span><span class="x">
</span><span class="x">&lt;svg width="</span><span class="cp">{{</span><span class="nv">width</span><span class="cp">}}</span><span class="x">" height="</span><span class="cp">{{</span><span class="nv">height</span><span class="cp">}}</span><span class="x">"&gt;
</span><span class="x">    </span><span class="c">{# background #}</span><span class="x">
</span><span class="x">    &lt;g stroke="#00ff00" stroke-width="</span><span class="cp">{{</span><span class="nv">line_stroke_width</span><span class="cp">}}</span><span class="x">"&gt;
</span><span class="x">        </span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">i</span><span class="o">,</span> <span class="kp">_</span> <span class="k">in</span> <span class="nv">scales</span> <span class="cp">%}</span><span class="x">
</span><span class="x">            </span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">j</span><span class="o">,</span> <span class="nv">line_width</span> <span class="k">in</span> <span class="nv">line_widths</span> <span class="cp">%}</span><span class="x">
</span><span class="x">                </span><span class="cp">{%</span> <span class="k">set</span> <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span> <span class="k">if</span> <span class="nv">side</span><span class="o">==</span><span class="s1">'left'</span> <span class="k">else</span> <span class="nv">width-line_width</span> <span class="cp">%}</span><span class="x">
</span><span class="x">                </span><span class="cp">{%</span> <span class="k">set</span> <span class="nv">dy</span> <span class="o">=</span> <span class="o">(</span><span class="nv">j</span> <span class="o">+</span> <span class="nv">i</span> <span class="o">*</span> <span class="nv">line_widths</span><span class="o">|</span><span class="nf">length</span><span class="o">)</span> <span class="o">*</span> <span class="nv">scale_height</span> <span class="o">+</span> <span class="nv">line_stroke_width</span><span class="cp">%}</span><span class="x">
</span><span class="x">                &lt;line x1="</span><span class="cp">{{</span><span class="nv">x</span><span class="cp">}}</span><span class="x">" x2="</span><span class="cp">{{</span><span class="nv">x</span> <span class="o">+</span> <span class="nv">line_width</span><span class="cp">}}</span><span class="x">" 
</span><span class="x">                    y1="</span><span class="cp">{{</span><span class="nv">height</span> <span class="o">-</span> <span class="nv">dy</span><span class="cp">}}</span><span class="x">" y2="</span><span class="cp">{{</span><span class="nv">height</span> <span class="o">-</span> <span class="nv">dy</span><span class="cp">}}</span><span class="x">" /&gt;
</span><span class="x">            </span><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x">
</span><span class="x">        </span><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x">
</span><span class="x">    &lt;/g&gt;
</span><span class="x">&lt;/svg&gt;</span></code></pre></div>

<p data-pid="rLEvEJmj">生成的svg图长这个样子</p>

<div><pre><code class="language-html"><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="p">&lt;</span><span class="nt">svg</span> <span class="na">height</span><span class="o">=</span><span class="s">"125"</span> <span class="na">width</span><span class="o">=</span><span class="s">"20"</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">g</span> <span class="na">stroke</span><span class="o">=</span><span class="s">"#00ff00"</span> <span class="na">stroke-width</span><span class="o">=</span><span class="s">"1.5"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"10"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"123.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"123.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"118.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"118.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"113.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"113.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"108.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"108.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"103.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"103.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"10"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"98.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"98.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"93.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"93.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"88.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"88.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"83.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"83.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"78.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"78.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"10"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"73.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"73.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"68.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"68.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"63.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"63.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"58.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"58.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"53.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"53.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"10"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"48.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"48.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"43.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"43.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"38.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"38.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"33.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"33.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"28.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"28.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"10"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"23.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"23.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"18.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"18.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"13.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"13.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"8.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"8.5"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">line</span> <span class="na">x1</span><span class="o">=</span><span class="s">"14"</span> <span class="na">x2</span><span class="o">=</span><span class="s">"20"</span> <span class="na">y1</span><span class="o">=</span><span class="s">"3.5"</span> <span class="na">y2</span><span class="o">=</span><span class="s">"3.5"</span><span class="p">/&gt;</span>
 <span class="p">&lt;/</span><span class="nt">g</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span></code></pre></div>

<h3 data-into-catalog-status="">字体</h3>

<p data-pid="w4oCM9LN">我没有找到JF-17中使用的字体，但是找到了一个开源的航空字体：<a href="https://link.zhihu.com/?target=https%3A//fonts.google.com/specimen/B612" class=" wrap external" target="_blank" rel="nofollow noreferrer">B612</a>，据说是空客在使用的字体。在unity中，可以使用TextMeshPro来生成与渲染我们自己选择的字体；另外，还支持一些超文本标记，后续扩展HUD中的其他文字显示会比较方便，比如左右对齐、居中、删除线之类的。</p>

<h3 data-into-catalog-status="">SDF着色</h3>

<p data-pid="lIdSzrfk">在初期的测试中，我发现图像的显示质量十分感人，即使把分辨率拉满，线条边缘也和抠图没扣干净一样，有一些残留的白色。参考TextMeshPro的字体显示方案，解决这个问题的方法就是采用SDF（<i>Signed Distance Field</i>）贴图来进行着色，参考这个<a href="https://link.zhihu.com/?target=http%3A//dotsquid.com/2020/11/19/sdf-ui-image/" class=" wrap external" target="_blank" rel="nofollow noreferrer">blog</a>。使用SDF后，线条的边缘在各种缩放下都能一直保持清晰，不过在贴图分辨率不高的情况下，转角处会更圆滑。</p>

<p data-pid="BqlP4mTW">SDF的原理很多地方都有了。简单来说问题的原因是图像渲染时的插值，在同一个色块的内部，插值工作的很好，但是在（字体/线条）的边缘处，颜色发生了突变，插值的结果就不科学了，会产生模糊的效果。对于字体、线条来说，这个问题就很严重，因此要采用一个适合插值的东西作为贴图的值输入着色器。由此产生了SDF的概念，它描述的是像素点与纹样边缘的距离，插值后也很科学（不完全对，比如字体转角处就会变圆滑），在着色器中，最后将这个距离输出为图像的alpha值，就可以获得一个清晰的边缘了，参考这个shader：<a href="https://link.zhihu.com/?target=https%3A//gist.github.com/dotsquid/15c91969a6cfa01b7563dd00fcde9e27" class=" wrap external" target="_blank" rel="nofollow noreferrer">Image-SDF</a>。</p>

<p data-pid="5fhVwESe">在github上，已经有工具能够将.png图像转化为SDF贴图了，我做了一点小改动:<a href="https://link.zhihu.com/?target=https%3A//github.com/beantowel/SDF-Generator" class=" wrap external" target="_blank" rel="nofollow noreferrer">SDF-Generator</a>；只写入alpha通道，不需要其他颜色信息了（基色直接在材质里设置）。这样在unity中导入贴图时可以选择alpha8格式，节省一点空间。</p>

<h3 data-into-catalog-status="">滚动刻度</h3>

<p data-pid="OviCtHdN">滚动刻度的范围可以非常大，比如速度表，其展示的范围从0~1000+都有可能（我采用了公制单位，就是任性），直接输出到一张图片中就是又细又长，体积太大。所以需要输出可变的刻度数字，再通过上下移动较小尺寸的组合对象来实现滚动的效果，当偏移超过+-0.5时，改变数字内容，再重置偏移量；多余的部分使用遮罩去除即可。</p>

<p><img src="https://pic4.zhimg.com/80/v2-47dd0d55e73e7f76896253fd524056e7_b.png" data-size="normal" data-rawwidth="133" data-rawheight="295" class="content_image lazy" width="133" data-actualsrc="https://pic4.zhimg.com/v2-47dd0d55e73e7f76896253fd524056e7_b.png" />
<img src="https://pic3.zhimg.com/80/v2-19f1c014b0dc6a6ae509f6c76c253a0e_b.png" data-size="normal" data-rawwidth="169" data-rawheight="255" class="content_image lazy" width="169" data-actualsrc="https://pic3.zhimg.com/v2-19f1c014b0dc6a6ae509f6c76c253a0e_b.png" /></p>
<h3 data-into-catalog-status="">姿态仪与速度矢量符号</h3>

<p data-pid="vjZRR38e">姿态仪也通过一整张图片实现，目前使用了均匀的刻度分划，方便进行平移，在大角度时效果不是太好，不过问题不大。</p>

<p><img src="https://pic4.zhimg.com/80/v2-e9462a0353a26440c15444d8ab2c6b3f_720w.jpg" data-size="normal" data-rawwidth="1354" data-rawheight="712" class="origin_image zh-lightbox-thumb lazy" width="1354" data-original="https://pic4.zhimg.com/v2-e9462a0353a26440c15444d8ab2c6b3f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e9462a0353a26440c15444d8ab2c6b3f_b.jpg" /></p>
<p data-pid="Qsc0tRnf">观察JF-17的HUD，可以发现姿态仪是如何展示滚转、俯仰、偏航、攻角数据的，特别地，速度矢量符号总是处在姿态仪的中心垂线上：</p>

<p><img src="https://pic1.zhimg.com/80/v2-40ed1abc5546b26a7d329aa3a0175100_720w.jpg" data-size="normal" data-rawwidth="721" data-rawheight="483" class="origin_image zh-lightbox-thumb lazy" width="721" data-original="https://pic1.zhimg.com/v2-40ed1abc5546b26a7d329aa3a0175100_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-40ed1abc5546b26a7d329aa3a0175100_b.jpg" /></p>
<p data-pid="Xb9fGx-w">滚转角和速度矢量符号的存在让姿态仪图像的平移稍微麻烦了亿点，需要整点三角函数才能计算出最终的平移量。</p>

<h3 data-into-catalog-status="">反射式成像效果</h3>

<p data-pid="i2RDSV70">图像中心的光线始终与载机轴线平行：这个实现起来比较简单，只要让HUD的xy坐标随着观察者一起移动即可。</p>

<p data-pid="lUn--Pmw">图像看起来在无限远处，成像大小仅和视角有关：可以让HUD始终保持在观察者前方的固定距离上，也可以让HUD随着观察者z坐标进行缩放。但是后者在观察者距离HUD平面很近的时候，缩放值会非常小，由于数值计算精度的原因，图像会抖动起来，效果非常糟糕。</p>

<p data-pid="OHF3UBeR">当姿态仪图像的大小确定后，我们实际上已经固定了视角-HUD中距离的换算关系了，否则姿态仪的虚拟地平线就不能和真正的地平线重合了。假设1弧度对应于HUD中2单位的距离，我们将HUD平面固定在观察者前3单位的位置上，那么此时HUD的缩放大小应该是1*3/2=1.5，即放大1.5倍。</p>

<p><br /></p>

<p data-pid="JfGsmHHg">最后整出来的效果就是这样：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1hS4y1j7pm/" class=" wrap external" target="_blank" rel="nofollow noreferrer">【超级鱼窝】从零开始的飞行模拟游戏 - HUD测试</a>，看起来海星</p>]]></content><author><name></name></author><category term="unity" /><summary type="html"><![CDATA[我希望在自制的游戏中实现一个简单的HUD（Head-up display 抬头显示器），使其看起来“像那么回事”；DCS游戏中的座舱制作的算比较精致的，鉴于财力问题，我们这次能够“抄作业“的最好对象就是JF-17”枭龙“战机的HUD了： 枭龙模组的HUD非常复杂，我们本次尝试只选择实现这些内容： 反射式成像的效果：图像中心的光线始终与载机轴线平行，看起来始终保持在正前方；图像看起来在无限远处，成像大小仅和视角有关，前后移动，并不会有近大远小的效果 速度、高度、航向指示器，且刻度有滚动效果 姿态仪，能够正确显示俯仰、偏航、滚转角度 速度矢量符号、机头指向 其他纯文字内容：攻角、过载、历史最大过载、马赫数、HUD模式等 贴图绘制 实现HUD的整体思路是将其中动态的部分拆解成独立的图片，来进行移动、旋转操作。通过一些取巧的手段，本次实现的内容都不需要动态生成mesh就能够完成，这样工作量就少了很多。 HUD中的图像除了文字就是一些线条，虽然不太复杂但是对位置的精准性要求比较高，所以我使用了手写svg的方式来绘制HUD。这种方法后续调整参数比较方便，同时不需要专业的软件，直接用文本编辑器就可以了。我构造了一个简单的工作流：首先写出要绘制内容的jinja2模板，然后通过python脚本填入参数生成.svg文件，再使用inkscape将其渲染为.png文件。 以左侧的速度表的滚动刻度为例，它的jinja2模板长这个样子： &lt;?xml version="1.0" encoding="UTF-8"?&gt; {% set height = scale_height * (scales|length * line_widths|length) %} {% set x_mid = width/2 %} {% set y_mid = height %} &lt;svg width="{{width}}" height="{{height}}"&gt; {# background #} &lt;g stroke="#00ff00" stroke-width="{{line_stroke_width}}"&gt; {% for i, _ in scales %} {% for j, line_width in line_widths %} {% set x = 0 if side=='left' else width-line_width %} {% set dy = (j + i * line_widths|length) * scale_height + line_stroke_width%} &lt;line x1="{{x}}" x2="{{x + line_width}}" y1="{{height - dy}}" y2="{{height - dy}}" /&gt; {% endfor %} {% endfor %} &lt;/g&gt; &lt;/svg&gt; 生成的svg图长这个样子 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;svg height="125" width="20"&gt; &lt;g stroke="#00ff00" stroke-width="1.5"&gt; &lt;line x1="10" x2="20" y1="123.5" y2="123.5"/&gt; &lt;line x1="14" x2="20" y1="118.5" y2="118.5"/&gt; &lt;line x1="14" x2="20" y1="113.5" y2="113.5"/&gt; &lt;line x1="14" x2="20" y1="108.5" y2="108.5"/&gt; &lt;line x1="14" x2="20" y1="103.5" y2="103.5"/&gt; &lt;line x1="10" x2="20" y1="98.5" y2="98.5"/&gt; &lt;line x1="14" x2="20" y1="93.5" y2="93.5"/&gt; &lt;line x1="14" x2="20" y1="88.5" y2="88.5"/&gt; &lt;line x1="14" x2="20" y1="83.5" y2="83.5"/&gt; &lt;line x1="14" x2="20" y1="78.5" y2="78.5"/&gt; &lt;line x1="10" x2="20" y1="73.5" y2="73.5"/&gt; &lt;line x1="14" x2="20" y1="68.5" y2="68.5"/&gt; &lt;line x1="14" x2="20" y1="63.5" y2="63.5"/&gt; &lt;line x1="14" x2="20" y1="58.5" y2="58.5"/&gt; &lt;line x1="14" x2="20" y1="53.5" y2="53.5"/&gt; &lt;line x1="10" x2="20" y1="48.5" y2="48.5"/&gt; &lt;line x1="14" x2="20" y1="43.5" y2="43.5"/&gt; &lt;line x1="14" x2="20" y1="38.5" y2="38.5"/&gt; &lt;line x1="14" x2="20" y1="33.5" y2="33.5"/&gt; &lt;line x1="14" x2="20" y1="28.5" y2="28.5"/&gt; &lt;line x1="10" x2="20" y1="23.5" y2="23.5"/&gt; &lt;line x1="14" x2="20" y1="18.5" y2="18.5"/&gt; &lt;line x1="14" x2="20" y1="13.5" y2="13.5"/&gt; &lt;line x1="14" x2="20" y1="8.5" y2="8.5"/&gt; &lt;line x1="14" x2="20" y1="3.5" y2="3.5"/&gt; &lt;/g&gt; &lt;/svg&gt; 字体 我没有找到JF-17中使用的字体，但是找到了一个开源的航空字体：B612，据说是空客在使用的字体。在unity中，可以使用TextMeshPro来生成与渲染我们自己选择的字体；另外，还支持一些超文本标记，后续扩展HUD中的其他文字显示会比较方便，比如左右对齐、居中、删除线之类的。 SDF着色 在初期的测试中，我发现图像的显示质量十分感人，即使把分辨率拉满，线条边缘也和抠图没扣干净一样，有一些残留的白色。参考TextMeshPro的字体显示方案，解决这个问题的方法就是采用SDF（Signed Distance Field）贴图来进行着色，参考这个blog。使用SDF后，线条的边缘在各种缩放下都能一直保持清晰，不过在贴图分辨率不高的情况下，转角处会更圆滑。 SDF的原理很多地方都有了。简单来说问题的原因是图像渲染时的插值，在同一个色块的内部，插值工作的很好，但是在（字体/线条）的边缘处，颜色发生了突变，插值的结果就不科学了，会产生模糊的效果。对于字体、线条来说，这个问题就很严重，因此要采用一个适合插值的东西作为贴图的值输入着色器。由此产生了SDF的概念，它描述的是像素点与纹样边缘的距离，插值后也很科学（不完全对，比如字体转角处就会变圆滑），在着色器中，最后将这个距离输出为图像的alpha值，就可以获得一个清晰的边缘了，参考这个shader：Image-SDF。 在github上，已经有工具能够将.png图像转化为SDF贴图了，我做了一点小改动:SDF-Generator；只写入alpha通道，不需要其他颜色信息了（基色直接在材质里设置）。这样在unity中导入贴图时可以选择alpha8格式，节省一点空间。 滚动刻度 滚动刻度的范围可以非常大，比如速度表，其展示的范围从0~1000+都有可能（我采用了公制单位，就是任性），直接输出到一张图片中就是又细又长，体积太大。所以需要输出可变的刻度数字，再通过上下移动较小尺寸的组合对象来实现滚动的效果，当偏移超过+-0.5时，改变数字内容，再重置偏移量；多余的部分使用遮罩去除即可。 姿态仪与速度矢量符号 姿态仪也通过一整张图片实现，目前使用了均匀的刻度分划，方便进行平移，在大角度时效果不是太好，不过问题不大。 观察JF-17的HUD，可以发现姿态仪是如何展示滚转、俯仰、偏航、攻角数据的，特别地，速度矢量符号总是处在姿态仪的中心垂线上： 滚转角和速度矢量符号的存在让姿态仪图像的平移稍微麻烦了亿点，需要整点三角函数才能计算出最终的平移量。 反射式成像效果 图像中心的光线始终与载机轴线平行：这个实现起来比较简单，只要让HUD的xy坐标随着观察者一起移动即可。 图像看起来在无限远处，成像大小仅和视角有关：可以让HUD始终保持在观察者前方的固定距离上，也可以让HUD随着观察者z坐标进行缩放。但是后者在观察者距离HUD平面很近的时候，缩放值会非常小，由于数值计算精度的原因，图像会抖动起来，效果非常糟糕。 当姿态仪图像的大小确定后，我们实际上已经固定了视角-HUD中距离的换算关系了，否则姿态仪的虚拟地平线就不能和真正的地平线重合了。假设1弧度对应于HUD中2单位的距离，我们将HUD平面固定在观察者前3单位的位置上，那么此时HUD的缩放大小应该是1*3/2=1.5，即放大1.5倍。 最后整出来的效果就是这样：【超级鱼窝】从零开始的飞行模拟游戏 - HUD测试，看起来海星]]></summary></entry><entry><title type="html">[jsbsim学习] 标准大气模型</title><link href="/unity/2021/08/22/atmosphere.html" rel="alternate" type="text/html" title="[jsbsim学习] 标准大气模型" /><published>2021-08-22T00:34:00+08:00</published><updated>2021-08-22T00:34:00+08:00</updated><id>/unity/2021/08/22/atmosphere</id><content type="html" xml:base="/unity/2021/08/22/atmosphere.html"><![CDATA[<p data-first-child="" data-pid="sixBNglE">在气动力的计算中，需要获知飞行器所在位置的空气密度来计算动压等参数，因此需要大气模型来计算（不同高度的）空气参数。jsbsim中采用了U.S. Standard Atmosphere, 1976", NASA TM-X-74335 （美国标准大气）模型。</p>

<p data-pid="JiVR9hF4">实际应用中不同地区的大气环境不一样（比如海平面温度不同），我们先忽略这个问题，只关注最基本的原理。基本的信息可以在wiki：<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/International_Standard_Atmosphere" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">en.wikipedia.org/wiki/I</span><span class="invisible">nternational_Standard_Atmosphere</span><span class="ellipsis"></span></a>里查看。</p>

<p><img src="https://pic3.zhimg.com/80/v2-8b13bdf0c60378d6638400b7829172d6_720w.jpg" data-caption="" data-size="normal" data-rawwidth="440" data-rawheight="587" class="origin_image zh-lightbox-thumb lazy" width="440" data-original="https://pic3.zhimg.com/v2-8b13bdf0c60378d6638400b7829172d6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8b13bdf0c60378d6638400b7829172d6_b.jpg" /></p>
<h2>高度</h2>

<p data-pid="qSAx1I1H">标准大气模型描述了不同高度上大气参数的变化，这里我们需要了解两种高度的定义：geometric altitude（标准高度）和geopotential altitude（势能高度）。前者很简单，就是物体与海平面间的距离；后者考虑了不同高度上重力加速度g的变化，通过g与高度差的积分计算出了重力不变情况下的等效高度，从名字上也能看出来，物体的势能可以直接用这个高度与地表重力加速度、质量相乘获得。</p>

<p><img src="https://pic1.zhimg.com/80/v2-49cb09b9d3914e6bf0201fb9299ae54c_b.png" data-caption="" data-size="normal" data-rawwidth="199" data-rawheight="57" class="content_image lazy" width="199" data-actualsrc="https://pic1.zhimg.com/v2-49cb09b9d3914e6bf0201fb9299ae54c_b.png" />
<img src="https://pic3.zhimg.com/80/v2-8f108c6e977889b039b899536d9e966a_b.png" data-caption="" data-size="normal" data-rawwidth="140" data-rawheight="56" class="content_image lazy" width="140" data-actualsrc="https://pic3.zhimg.com/v2-8f108c6e977889b039b899536d9e966a_b.png" /></p>
<p data-pid="e7m70gqr">实际应用中不需要计算复杂的积分，可以通过地球半径来计算势能高度，以下是jsbsim中的实现，只需要普通的四则运算即可 ：</p>

<p><img src="https://pic4.zhimg.com/80/v2-0ecf0e8ab2851786c94a10bdf270d0cb_b.png" data-caption="" data-size="normal" data-rawwidth="1670" data-rawheight="112" class="origin_image zh-lightbox-thumb lazy" width="1670" data-original="https://pic4.zhimg.com/v2-0ecf0e8ab2851786c94a10bdf270d0cb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-0ecf0e8ab2851786c94a10bdf270d0cb_b.png" /></p>
<h2>温度、压强、密度</h2>

<p data-pid="V2WzjKBe">在标准模型中，温度基本是随着高度（分段）线性变化的，所以我们可以方便地将这些数据存在表格里，进行插值计算，而其他两个参数则可以通过求解方程获得。</p>

<p data-pid="UCXRxM1c">根据流体静力平衡和理想气体模型，有下面两个公式：</p>

<p><img src="https://pic3.zhimg.com/80/v2-259e149b0885fa948538dd5ac28591ee_b.png" data-caption="" data-size="normal" data-rawwidth="99" data-rawheight="50" class="content_image lazy" width="99" data-actualsrc="https://pic3.zhimg.com/v2-259e149b0885fa948538dd5ac28591ee_b.png" />
<img src="https://pic2.zhimg.com/80/v2-ea45c97c6e3519e2f686721c9f4c8ee1_b.png" data-caption="" data-size="normal" data-rawwidth="140" data-rawheight="26" class="content_image lazy" width="140" data-actualsrc="https://pic2.zhimg.com/v2-ea45c97c6e3519e2f686721c9f4c8ee1_b.png" /></p>
<p data-pid="6gv1Xdfk">替换变量再化简一下的话就是</p>

<p data-pid="-5dhkXxN"><span class="ztext-math" data-eeimg="1" data-tex="dlnP = \frac{-g(h)}{R_{spec}T(h)}dh\\">dlnP = \frac{-g(h)}{R_{spec}T(h)}dh\\</span> </p>

<p data-pid="zvj8B3Tg">在温度随高度线性变化的分段函数上积分，可以进一步简化：</p>

<p data-pid="G3vHM5Zy"><span class="ztext-math" data-eeimg="1" data-tex="\frac{P_1}{P_0} = \frac{T_0}{T_0+k \Delta h}^{\frac{g_0}{R_{spec} k}}\\">\frac{P_1}{P_0} = \frac{T_0}{T_0+k \Delta h}^{\frac{g_0}{R_{spec} k}}\\</span></p>

<p data-pid="nMWDwGyX">其中k是温度直减率（<i>lapse rate</i>）， <span class="ztext-math" data-eeimg="1" data-tex="P_0">P_0</span> 为分段函数转折点压强，与转折点间的（势能高度）差为 <span class="ztext-math" data-eeimg="1" data-tex="\Delta h">\Delta h</span> 。通过这个公式与预先计算好的各转折点压强，就能获得各高度上的压强，气体密度亦可以再通过理想气体模型获得。</p>

<p data-pid="9x5ygNRm">需要注意的是温度梯度较小的时候上式的k-&gt;0，直接进行数值计算不太合适，需要将上式退化为</p>

<p data-pid="DsdNE0Bk"><span class="ztext-math" data-eeimg="1" data-tex="\frac{P_1}{P_0} = e^{\frac{-g_0 \Delta h}{R_{spec}T_0}}\\">\frac{P_1}{P_0} = e^{\frac{-g_0 \Delta h}{R_{spec}T_0}}\\</span> </p>

<p></p>]]></content><author><name></name></author><category term="unity" /><summary type="html"><![CDATA[在气动力的计算中，需要获知飞行器所在位置的空气密度来计算动压等参数，因此需要大气模型来计算（不同高度的）空气参数。jsbsim中采用了U.S. Standard Atmosphere, 1976", NASA TM-X-74335 （美国标准大气）模型。 实际应用中不同地区的大气环境不一样（比如海平面温度不同），我们先忽略这个问题，只关注最基本的原理。基本的信息可以在wiki：https://en.wikipedia.org/wiki/International_Standard_Atmosphere里查看。 高度 标准大气模型描述了不同高度上大气参数的变化，这里我们需要了解两种高度的定义：geometric altitude（标准高度）和geopotential altitude（势能高度）。前者很简单，就是物体与海平面间的距离；后者考虑了不同高度上重力加速度g的变化，通过g与高度差的积分计算出了重力不变情况下的等效高度，从名字上也能看出来，物体的势能可以直接用这个高度与地表重力加速度、质量相乘获得。 实际应用中不需要计算复杂的积分，可以通过地球半径来计算势能高度，以下是jsbsim中的实现，只需要普通的四则运算即可 ： 温度、压强、密度 在标准模型中，温度基本是随着高度（分段）线性变化的，所以我们可以方便地将这些数据存在表格里，进行插值计算，而其他两个参数则可以通过求解方程获得。 根据流体静力平衡和理想气体模型，有下面两个公式： 替换变量再化简一下的话就是 dlnP = \frac{-g(h)}{R_{spec}T(h)}dh\\ 在温度随高度线性变化的分段函数上积分，可以进一步简化： \frac{P_1}{P_0} = \frac{T_0}{T_0+k \Delta h}^{\frac{g_0}{R_{spec} k}}\\ 其中k是温度直减率（lapse rate）， P_0 为分段函数转折点压强，与转折点间的（势能高度）差为 \Delta h 。通过这个公式与预先计算好的各转折点压强，就能获得各高度上的压强，气体密度亦可以再通过理想气体模型获得。 需要注意的是温度梯度较小的时候上式的k-&gt;0，直接进行数值计算不太合适，需要将上式退化为 \frac{P_1}{P_0} = e^{\frac{-g_0 \Delta h}{R_{spec}T_0}}\\]]></summary></entry><entry><title type="html">[jsbsim学习] 配置文件解析</title><link href="/unity/2021/05/23/jsbsim-parse.html" rel="alternate" type="text/html" title="[jsbsim学习] 配置文件解析" /><published>2021-05-23T23:04:00+08:00</published><updated>2021-05-23T23:04:00+08:00</updated><id>/unity/2021/05/23/jsbsim-parse</id><content type="html" xml:base="/unity/2021/05/23/jsbsim-parse.html"><![CDATA[<p data-first-child="" data-pid="Uepj_RUc"><a href="https://zhuanlan.zhihu.com/p/366482912" class="internal">上文</a>我们讨论解读了jsbsim的配置文件，现在让我们使用程序来加载这个配置文件，进行计算吧。</p>

<p data-pid="vYBod8AN">一个C#语言的“简易版”jsbsim代码还在开发中：<a href="https://link.zhihu.com/?target=https%3A//github.com/beantowel/minimal-jsim" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/beantowel/mi</span><span class="invisible">nimal-jsim</span><span class="ellipsis"></span></a> 预期后续能够作为一个第三方包供unity开发使用。</p>

<h3>xml反序列化</h3>

<p data-pid="86WrIBD-">在解析配置文件时，我发现实际上jsbsim提供了一份xml的结构描述文件（schema）：<a href="https://link.zhihu.com/?target=https%3A//github.com/JSBSim-Team/jsbsim/blob/master/JSBSim.xsd" class=" wrap external" target="_blank" rel="nofollow noreferrer">JSBSim.xsd</a>。而且里面也提供了一些注释，可以对上文进行补充。我们使用 .net 提供的程序 <a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/dotnet/standard/serialization/xml-schema-definition-tool-xsd-exe" class=" wrap external" target="_blank" rel="nofollow noreferrer">xsd.exe</a> 直接来生成 c# 中的类，对配置文件进行反序列化。使用方法也很简单，运行：</p>

<p data-pid="N5gaazsW"><code>xsd JSBSim.xsd /classes</code> </p>

<p data-pid="OcqiqZ_L">就可以了，但是如果我们直接运行这个命令的话，会发现程序报错，因为这个JSBSim存在group元素的循环引用。如下图中func_group -&gt; product -&gt; func_group 的循环。</p>

<p><img src="https://pic2.zhimg.com/80/v2-650def5cf34cd0b6c0c9cbdea122ecc5_720w.jpg" data-caption="" data-size="normal" data-rawwidth="567" data-rawheight="477" class="origin_image zh-lightbox-thumb lazy" width="567" data-original="https://pic2.zhimg.com/v2-650def5cf34cd0b6c0c9cbdea122ecc5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-650def5cf34cd0b6c0c9cbdea122ecc5_b.jpg" />
<img src="https://pic3.zhimg.com/80/v2-955548fc5580c43c5fefd7481f9a1996_720w.jpg" data-caption="" data-size="normal" data-rawwidth="625" data-rawheight="326" class="origin_image zh-lightbox-thumb lazy" width="625" data-original="https://pic3.zhimg.com/v2-955548fc5580c43c5fefd7481f9a1996_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-955548fc5580c43c5fefd7481f9a1996_b.jpg" /></p>
<p data-pid="D8T66pGO">在xsd文件中，我们可以认为 xs:group 类似C语言中的宏命令，在 xsd.exe 程序生成类的过程中是会直接展开的，因此循环引用会导致无穷展开，是非法的。可以参考这个<a href="https://link.zhihu.com/?target=https%3A//devio.wordpress.com/2012/05/22/dealing-with-circular-group-reference-errors-in-xsd-exe/" class=" wrap external" target="_blank" rel="nofollow noreferrer">blog</a>来进行一些修改绕过这个限制，具体细节上因为xsd不一样不能直接照搬，我直接把修改后的xsd和生成的class贴在<a href="https://link.zhihu.com/?target=https%3A//gist.github.com/beantowel/9a404dbdd5d764294d5d456a1fd8426d" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>。 这样，我们就能对配置文件进行反序列化了。</p>

<h3>质量、转动惯量解析</h3>

<p><img src="https://pic2.zhimg.com/80/v2-1043dcbaee4d4a18f9aa849227e44725_720w.jpg" data-caption="" data-size="normal" data-rawwidth="551" data-rawheight="215" class="origin_image zh-lightbox-thumb lazy" width="551" data-original="https://pic2.zhimg.com/v2-1043dcbaee4d4a18f9aa849227e44725_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1043dcbaee4d4a18f9aa849227e44725_b.jpg" /></p>
<p data-pid="WDpBPC24">unity仅支持转动张量（惯性主轴主成分构成的Vector3）+ 主轴旋转角格式的输入，即inertiaTensor和inertiaTensorRotation，但是我们的配置文件中给出的是一般的转动惯量形式，因此需要做一下转换。 PhysX 中提供了一个函数<a href="https://link.zhihu.com/?target=https%3A//github.com/NVIDIAGameWorks/PhysX-3.4/blob/master/PxShared/src/foundation/src/PsMathUtils.cpp" class=" wrap external" target="_blank" rel="nofollow noreferrer">PxDiagonalize</a>来对转动惯量进行对角化，可惜我们使用的是c#脚本，无法直接引用c++的库。我尝试过使用PhysX.Net，但是发现里面似乎也没有提供这个方法，并且文档质量太差。最终我还是选择拿c#把c++代码抄一遍完事，简单快捷。</p>

<p data-pid="ho65x-ay">这个算法还挺有趣的，在下面贴一下。主要思路就是通过x，y或z轴的旋转一步步迭代将转动惯量对角化，举个不恰当的例子，就像转魔方一样。区别在于这里的每一步操作都是较优的逼近方程的解，而魔方在我这种菜鸡手上可能永远都转不出来。在这里，m是输入的转动惯量，q是对m的旋转（四元数形式，其对应的旋转矩阵是axes），d=qT m q 是旋转后的转动惯量，迭代的终止条件就是 d 变为对角化矩阵。迭代中我们将每次的x，y或z轴旋转操作累计（累乘）在q上，这里算法的关键就是如何选出我们每次要转的轴，和算出要旋转的角度。</p>

<p data-pid="bizATdzm">算法选择了惯性积最大的那个轴开刀，即如果Iyz比Ixy、Ixz都大的情况下，优先绕x轴进行调整。 此时要调整的角度phi的余切cot(2 phi)=(Iyy - Izz) / (2 Iyz)  ，这个角度就是经过旋转后，能够取得Iyz最小的角度，通过坐标变换和二次函数极值点可以推导出 。</p>

<p data-pid="Sje5BUwt">迭代法的收敛性不会证，但是直观上感觉旋转几次基本就够了（注意迭代次数可能大于3次，并不是在每一个轴上旋转一次就足够了，需要来回调整）。代码里设定的最大迭代次数是24次，也说明这个收敛的挺快了。</p>

<div><pre><code class="language-cpp"><span class="n">PX_FOUNDATION_API</span> <span class="n">PxVec3</span> <span class="n">physx</span><span class="o">::</span><span class="n">PxDiagonalize</span><span class="p">(</span><span class="k">const</span> <span class="n">PxMat33</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">PxQuat</span><span class="o">&amp;</span> <span class="n">massFrame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// jacobi rotation using quaternions (from an idea of Stan Melax, with fix for precision issues)
</span><span class="c1"></span>
	<span class="k">const</span> <span class="n">PxU32</span> <span class="n">MAX_ITERS</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>

	<span class="n">PxQuat</span> <span class="n">q</span> <span class="o">=</span> <span class="n">PxQuat</span><span class="p">(</span><span class="n">PxIdentity</span><span class="p">);</span>

	<span class="n">PxMat33</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_ITERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PxMat33</span> <span class="nf">axes</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">axes</span><span class="p">.</span><span class="n">getTranspose</span><span class="p">()</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="n">axes</span><span class="p">;</span>

		<span class="n">PxReal</span> <span class="n">d0</span> <span class="o">=</span> <span class="n">PxAbs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">PxAbs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">PxAbs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">PxU32</span> <span class="n">a</span> <span class="o">=</span> <span class="n">PxU32</span><span class="p">(</span><span class="n">d0</span> <span class="o">&gt;</span> <span class="n">d1</span> <span class="o">&amp;&amp;</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="n">d2</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// rotation axis index, from largest off-diagonal
</span><span class="c1"></span>		<span class="c1">// element
</span><span class="c1"></span>
		<span class="n">PxU32</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">shdfnd</span><span class="o">::</span><span class="n">getNextIndex3</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">shdfnd</span><span class="o">::</span><span class="n">getNextIndex3</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">a2</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0f</span> <span class="o">||</span> <span class="n">PxAbs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">a1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">a2</span><span class="p">][</span><span class="n">a2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">2e6</span><span class="n">f</span> <span class="o">*</span> <span class="n">PxAbs</span><span class="p">(</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">a2</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">PxReal</span> <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">a1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">a2</span><span class="p">][</span><span class="n">a2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0f</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">a2</span><span class="p">]);</span> <span class="c1">// cot(2 * phi), where phi is the rotation angle
</span><span class="c1"></span>		<span class="n">PxReal</span> <span class="n">absw</span> <span class="o">=</span> <span class="n">PxAbs</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

		<span class="n">PxQuat</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">absw</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">indexedRotation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">w</span><span class="p">),</span> <span class="mf">1.f</span><span class="p">);</span> <span class="c1">// h will be very close to 1, so use small angle approx instead
</span><span class="c1"></span>		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">PxReal</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">absw</span> <span class="o">+</span> <span class="n">PxSqrt</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// absolute value of tan phi
</span><span class="c1"></span>			<span class="n">PxReal</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">PxSqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>          <span class="c1">// absolute value of cos phi
</span><span class="c1"></span>
			<span class="n">PX_ASSERT</span><span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// |w|&lt;1000 guarantees this with typical IEEE754 machine eps (approx 6e-8)
</span><span class="c1"></span>			<span class="n">r</span> <span class="o">=</span> <span class="n">indexedRotation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">PxSqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">PxSign</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">PxSqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">r</span><span class="p">).</span><span class="n">getNormalized</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">massFrame</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="k">return</span> <span class="nf">PxVec3</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">column0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">column1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">column2</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3>空气动力函数解析</h3>

<p data-pid="C-SKXi7N">jsbsim的配置文件支持了相当多的函数类型，不过在我们选择的f16配置文件中，aerodynamics节点下的子函数只涉及到了product和table两种类型，解析起来比较简单，可以参考文章第一段中提供的代码。</p>

<p data-pid="DUupoGQo">需要注意我们的程序中使用公制单位存储所有数据，property的标识符“node”最后一部分通常会给出单位，便于转换；但是table表格中的数据未给出单位，同时其也可能不是无量纲数，需要额外处理。在f16的配置文件中，所有的表格都最终都是通过product乘法计算出力/力矩的，尚且可以通过其他变量的单位反推其量纲进行处理。</p>

<p data-pid="2z9_gEIK">对于Property的处理还没有发现特别好的方案，由于jsbsim采用了这种相当于全局变量的架构，要想使用它的配置文件，我们的组件也必然受到这种设计的影响，这种全局变量的优点是直观、程序设计简单，缺点是对外提供接口语义不清晰、Property间如果有依赖关系容易产生隐形bug。</p>]]></content><author><name></name></author><category term="unity" /><summary type="html"><![CDATA[上文我们讨论解读了jsbsim的配置文件，现在让我们使用程序来加载这个配置文件，进行计算吧。 一个C#语言的“简易版”jsbsim代码还在开发中：https://github.com/beantowel/minimal-jsim 预期后续能够作为一个第三方包供unity开发使用。 xml反序列化 在解析配置文件时，我发现实际上jsbsim提供了一份xml的结构描述文件（schema）：JSBSim.xsd。而且里面也提供了一些注释，可以对上文进行补充。我们使用 .net 提供的程序 xsd.exe 直接来生成 c# 中的类，对配置文件进行反序列化。使用方法也很简单，运行： xsd JSBSim.xsd /classes 就可以了，但是如果我们直接运行这个命令的话，会发现程序报错，因为这个JSBSim存在group元素的循环引用。如下图中func_group -&gt; product -&gt; func_group 的循环。 在xsd文件中，我们可以认为 xs:group 类似C语言中的宏命令，在 xsd.exe 程序生成类的过程中是会直接展开的，因此循环引用会导致无穷展开，是非法的。可以参考这个blog来进行一些修改绕过这个限制，具体细节上因为xsd不一样不能直接照搬，我直接把修改后的xsd和生成的class贴在这里。 这样，我们就能对配置文件进行反序列化了。 质量、转动惯量解析 unity仅支持转动张量（惯性主轴主成分构成的Vector3）+ 主轴旋转角格式的输入，即inertiaTensor和inertiaTensorRotation，但是我们的配置文件中给出的是一般的转动惯量形式，因此需要做一下转换。 PhysX 中提供了一个函数PxDiagonalize来对转动惯量进行对角化，可惜我们使用的是c#脚本，无法直接引用c++的库。我尝试过使用PhysX.Net，但是发现里面似乎也没有提供这个方法，并且文档质量太差。最终我还是选择拿c#把c++代码抄一遍完事，简单快捷。 这个算法还挺有趣的，在下面贴一下。主要思路就是通过x，y或z轴的旋转一步步迭代将转动惯量对角化，举个不恰当的例子，就像转魔方一样。区别在于这里的每一步操作都是较优的逼近方程的解，而魔方在我这种菜鸡手上可能永远都转不出来。在这里，m是输入的转动惯量，q是对m的旋转（四元数形式，其对应的旋转矩阵是axes），d=qT m q 是旋转后的转动惯量，迭代的终止条件就是 d 变为对角化矩阵。迭代中我们将每次的x，y或z轴旋转操作累计（累乘）在q上，这里算法的关键就是如何选出我们每次要转的轴，和算出要旋转的角度。 算法选择了惯性积最大的那个轴开刀，即如果Iyz比Ixy、Ixz都大的情况下，优先绕x轴进行调整。 此时要调整的角度phi的余切cot(2 phi)=(Iyy - Izz) / (2 Iyz) ，这个角度就是经过旋转后，能够取得Iyz最小的角度，通过坐标变换和二次函数极值点可以推导出 。 迭代法的收敛性不会证，但是直观上感觉旋转几次基本就够了（注意迭代次数可能大于3次，并不是在每一个轴上旋转一次就足够了，需要来回调整）。代码里设定的最大迭代次数是24次，也说明这个收敛的挺快了。 PX_FOUNDATION_API PxVec3 physx::PxDiagonalize(const PxMat33&amp; m, PxQuat&amp; massFrame) { // jacobi rotation using quaternions (from an idea of Stan Melax, with fix for precision issues) const PxU32 MAX_ITERS = 24; PxQuat q = PxQuat(PxIdentity); PxMat33 d; for(PxU32 i = 0; i &lt; MAX_ITERS; i++) { PxMat33 axes(q); d = axes.getTranspose() * m * axes; PxReal d0 = PxAbs(d[1][2]), d1 = PxAbs(d[0][2]), d2 = PxAbs(d[0][1]); PxU32 a = PxU32(d0 &gt; d1 &amp;&amp; d0 &gt; d2 ? 0 : d1 &gt; d2 ? 1 : 2); // rotation axis index, from largest off-diagonal // element PxU32 a1 = shdfnd::getNextIndex3(a), a2 = shdfnd::getNextIndex3(a1); if(d[a1][a2] == 0.0f || PxAbs(d[a1][a1] - d[a2][a2]) &gt; 2e6f * PxAbs(2.0f * d[a1][a2])) break; PxReal w = (d[a1][a1] - d[a2][a2]) / (2.0f * d[a1][a2]); // cot(2 * phi), where phi is the rotation angle PxReal absw = PxAbs(w); PxQuat r; if(absw &gt; 1000) r = indexedRotation(a, 1 / (4 * w), 1.f); // h will be very close to 1, so use small angle approx instead else { PxReal t = 1 / (absw + PxSqrt(w * w + 1)); // absolute value of tan phi PxReal h = 1 / PxSqrt(t * t + 1); // absolute value of cos phi PX_ASSERT(h != 1); // |w|&lt;1000 guarantees this with typical IEEE754 machine eps (approx 6e-8) r = indexedRotation(a, PxSqrt((1 - h) / 2) * PxSign(w), PxSqrt((1 + h) / 2)); } q = (q * r).getNormalized(); } massFrame = q; return PxVec3(d.column0.x, d.column1.y, d.column2.z); } 空气动力函数解析 jsbsim的配置文件支持了相当多的函数类型，不过在我们选择的f16配置文件中，aerodynamics节点下的子函数只涉及到了product和table两种类型，解析起来比较简单，可以参考文章第一段中提供的代码。 需要注意我们的程序中使用公制单位存储所有数据，property的标识符“node”最后一部分通常会给出单位，便于转换；但是table表格中的数据未给出单位，同时其也可能不是无量纲数，需要额外处理。在f16的配置文件中，所有的表格都最终都是通过product乘法计算出力/力矩的，尚且可以通过其他变量的单位反推其量纲进行处理。 对于Property的处理还没有发现特别好的方案，由于jsbsim采用了这种相当于全局变量的架构，要想使用它的配置文件，我们的组件也必然受到这种设计的影响，这种全局变量的优点是直观、程序设计简单，缺点是对外提供接口语义不清晰、Property间如果有依赖关系容易产生隐形bug。]]></summary></entry><entry><title type="html">[jsbsim学习] 飞行器模型配置文件解读</title><link href="/unity/2021/04/22/jsbsim-conf.html" rel="alternate" type="text/html" title="[jsbsim学习] 飞行器模型配置文件解读" /><published>2021-04-22T00:49:00+08:00</published><updated>2021-04-22T00:49:00+08:00</updated><id>/unity/2021/04/22/jsbsim-conf</id><content type="html" xml:base="/unity/2021/04/22/jsbsim-conf.html"><![CDATA[<p data-first-child="" data-pid="6DOXL1JG"><a href="https://link.zhihu.com/?target=https%3A//jsbsim-team.github.io/jsbsim-reference-manual/" class=" wrap external" target="_blank" rel="nofollow noreferrer">jsbsim</a>是一个开源的飞行力学仿真软件，学习它的主要目的是希望能够实现一个类似IL2/1战争雷霆这样的空战游戏。虽然jsbsim能够通过socket通信直接进行调用，但是考虑到调用/打包的问题，以及二次开发的目的，决定还是在unity中使用C#实现一个简化版的气动仿真模型。最终的模型应当能够以飞行器当前状态为输入，输出6个自由度上的力/力矩，接入unity刚体组件。</p>

<p data-pid="qmQAL6gP">以jsbsim自带的<a href="https://link.zhihu.com/?target=https%3A//github.com/JSBSim-Team/jsbsim/tree/master/aircraft/f16" class=" wrap external" target="_blank" rel="nofollow noreferrer">f-16</a>模型配置文件 <code>f16.xml</code>为例，我们来看看里面都写了什么。</p>

<p><img src="https://pic1.zhimg.com/80/v2-11c792c57ecebee1d994ac0f0180da50_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1188" data-rawheight="1173" class="origin_image zh-lightbox-thumb lazy" width="1188" data-original="https://pic1.zhimg.com/v2-11c792c57ecebee1d994ac0f0180da50_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-11c792c57ecebee1d994ac0f0180da50_b.jpg" /></p>
<p data-pid="tiM90OAW">看一下xml根节点，对于实现一个简化版仿真模型来说，<code>metrics</code>,<code>mass_balance</code>,<code>aerodynamics</code>看起来比较重要。其他的地面互动、推力以及自动控制暂时先不看了 。顺便说一句，jsbsim最早的侧重点就是进行自动控制策略的仿真，所以<code>flight_control</code>还是挺详细的，但是这个还是先不和气动力学模块混在一起看了。</p>

<p data-pid="eq8VvK13">实际上，写这篇文章的动机主要就是把配置文件里的缩写含义都搞清楚，以便后续查找。因为里面的缩写很多都是不当人级别的，实乃一大恶习；另一大恶习就是jsbsim中大量实用英制单位（imperial帝国主义单位 ），我们社会主义的花朵看不到SI单位实在很烦躁。</p>

<h3>metrics 节点 </h3>

<p data-pid="lSVghveT">先来看看metrics，它描述了飞行器的几个尺寸/位置指标</p>

<p><img src="https://pic4.zhimg.com/80/v2-f312cd9edf32878f3be0546a3ea238cb_720w.jpg" data-caption="" data-size="normal" data-rawwidth="729" data-rawheight="857" class="origin_image zh-lightbox-thumb lazy" width="729" data-original="https://pic4.zhimg.com/v2-f312cd9edf32878f3be0546a3ea238cb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f312cd9edf32878f3be0546a3ea238cb_b.jpg" /></p>
<ul>
<li data-pid="FIvgVgZJ">wingarea=翼面积，单位 FT2=feet^2=平方英尺</li>
<li data-pid="U2EmFEWb">wingspan 翼展，单位 FT=feet=平方英尺</li>
<li data-pid="STOEI0QR">chord 机翼弦长</li>
<li data-pid="jNi_b38m">htailarea=horizontal tail area=水平尾翼面积</li>
<li data-pid="fU4TpxaN">htailarm=水平尾翼力臂（相对气动中心AERORP/CG）</li>
<li data-pid="KI7yRvrC">vtailarea=vertical tail area=垂直尾翼面积</li>
<li data-pid="CeWzGvgq">vtailarm=垂直尾翼力臂</li>
<li data-pid="QSvSiNpY">AERORP=aerodynamic reference point=气动参考点，单位 IN=inch=英寸</li>
<li data-pid="WaZQHXeG">EYEPOINT=飞行员视角位置</li>
<li data-pid="rRK4PY3B">VRP=visual reference point=视觉参考点</li>
</ul>

<p data-pid="DJe3fhNX">我们看到了很多长度、面积、位置信息，在此需要补充一下jsbsim中的<a href="https://link.zhihu.com/?target=http%3A//www.city-gallery.com/knoblock/projects/flightgear/Docs/coords.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">坐标系约定</a>。其中所谓VRP就是下图中的一段偏移量，用来确定飞行器“鼻尖”和建模时使用的坐标原点之间的位置关系。</p>

<p><img src="https://pic3.zhimg.com/80/v2-2115ca8740599e61a0cda4d5ed3d154e_720w.jpg" data-caption="" data-size="normal" data-rawwidth="840" data-rawheight="553" class="origin_image zh-lightbox-thumb lazy" width="840" data-original="https://pic3.zhimg.com/v2-2115ca8740599e61a0cda4d5ed3d154e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-2115ca8740599e61a0cda4d5ed3d154e_b.jpg" /></p>
<h3>mass_balance节点</h3>

<p data-pid="6aYpCTDl">mass_balance描述了飞行器的质量分布参数，梦回理论力学</p>

<p><img src="https://pic4.zhimg.com/80/v2-75391e87e4b668572764c14c77bf9163_720w.jpg" data-caption="" data-size="normal" data-rawwidth="681" data-rawheight="780" class="origin_image zh-lightbox-thumb lazy" width="681" data-original="https://pic4.zhimg.com/v2-75391e87e4b668572764c14c77bf9163_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-75391e87e4b668572764c14c77bf9163_b.jpg" /></p>
<ul>
<li data-pid="etrdclwu">ixx, iyy, izz, ixy, ixz, iyz=构成刚体<a href="https://link.zhihu.com/?target=https%3A//ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec26.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">惯性张量</a>的六个参数，单位 SLUG*FT2，其中<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Slug_%28unit%29" class=" wrap external" target="_blank" rel="nofollow noreferrer">slug</a>是一个质量单位</li>
<li data-pid="nNyarwc4">emptywt=empty weight=空载重量，单位 LBS=<i>Libra pondo=</i>磅</li>
<li data-pid="20PK5xOD">CG=center of gravity=重心</li>
<li data-pid="IT-m83Iy">Pilot=飞行员，POINTMASS=质点</li>
</ul>

<p data-pid="9HtwgryY">这里面大概就惯性张量比较难懂了，但是不用害怕，就算啥也不会直接灌倒unity的刚体组件里就行了。平面转动的惯量比较好理解，三维情况比较麻烦的一点就是刚体角动量与瞬时角速度一般方向不同，简单来说，根据质量分布的参数我们可以推断出飞行器在力矩作用下将会如何旋转。</p>

<h3>aerodynamics节点</h3>

<p data-pid="mVGSLT-u">这是要分析的重点数据，内容也很多，已经不能全部展开看了，看一下它的子节点吧</p>

<p><img src="https://pic3.zhimg.com/80/v2-54f73855dcc6d16efca0f6f0ea443482_720w.jpg" data-caption="" data-size="normal" data-rawwidth="760" data-rawheight="804" class="origin_image zh-lightbox-thumb lazy" width="760" data-original="https://pic3.zhimg.com/v2-54f73855dcc6d16efca0f6f0ea443482_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-54f73855dcc6d16efca0f6f0ea443482_b.jpg" /></p>
<ul>
<li data-pid="cXm2ZD8X">kCLge=k lift coefficient (by) ground effect=升力系数由于地面效应产生的变化</li>
<li data-pid="Jnn2VANE">h_b-mac-ft=height-mean aerodynamic chord-feet</li>
</ul>

<p data-pid="pAWwiNZi">除了一个比较出戏的地面效应函数，其他<a href="https://link.zhihu.com/?target=https%3A//jsbsim-team.github.io/jsbsim-reference-manual/mypages/user-manual-forces-and-moments/" class=" wrap external" target="_blank" rel="nofollow noreferrer">六项</a>（axis=轴）很好理解，分别对应了沿x，y，z轴平动、绕x，y，z轴转动这六个刚体运动自由度。aerodynamics节点里面包含了大量的表格，需要注意jsbsim的实现中各种非线性的公式/函数都是靠查表完成的，并且采用线性插值（没找到二/三维表格是如何插值的，姑且当作双/三线性插值）。</p>

<h3>DRAG 轴</h3>

<p><img src="https://pic1.zhimg.com/80/v2-cb324ff17a0602ef0ee1b97ebae8d10c_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1121" data-rawheight="891" class="origin_image zh-lightbox-thumb lazy" width="1121" data-original="https://pic1.zhimg.com/v2-cb324ff17a0602ef0ee1b97ebae8d10c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cb324ff17a0602ef0ee1b97ebae8d10c_b.jpg" /></p>
<ul>
<li data-pid="_KSXyHRo">CDDh=drag coefficient (by) horizontal deflection=水平尾翼偏转的阻力</li>
<li data-pid="pEivzJIt">qbar-psf=<span class="ztext-math" data-eeimg="1" data-tex="\bar{q}">\bar{q}</span>=filght dynamic pressure=空气动压，单位 psf=pounds per square foot=磅力/平方英尺</li>
<li data-pid="HAvPsR9l">Sw-sqft=<span class="ztext-math" data-eeimg="1" data-tex="S_W">S_W</span>=Wing area=翼面积，单位 sqft=squre foot=平方英尺</li>
<li data-pid="zhGcSrx9">alpha-rad=<span class="ztext-math" data-eeimg="1" data-tex="\alpha">\alpha</span>=angle of attack=攻角，单位=radians=弧度</li>
<li data-pid="gnQtpyuc">elevator-pos-rad=升降舵角度</li>
</ul>

<p data-pid="1Pl_2Qfj">jsbsim里面的函数大部分都是乘积与查表，并且函数也自带description能够比较清晰地描述其用途，后面就不重复讨论了，只把函数、变量的缩写和物理含义写下来。</p>

<ul>
<li data-pid="6OQa9SUk">mach=马赫数</li>
<li data-pid="Dn63LhXL">lef-pos-rad=leading edge flap position=前缘缝翼角度</li>
<li data-pid="WKt-0YcD">flapreon-mix-rad=襟副翼混合角度？</li>
<li data-pid="cEQayN7J">gear-pos-norm=起落架位置，单位 norm=normalized=归一化（的值，0~1）</li>
<li data-pid="pSYMCSgl">speedbrake-pos-rad=减速板角度</li>
<li data-pid="vhyNfc3Y">q-aero-rad_sec=（考虑了空速的）俯仰角速度，p,q,e三个角速度的定义如<a href="https://link.zhihu.com/?target=https%3A//jsbsim-team.github.io/jsbsim-reference-manual/mypages/formulation-manual-equations-of-motion/" class=" wrap external" target="_blank" rel="nofollow noreferrer">下图</a>：</li>
</ul>

<p><img src="https://pic2.zhimg.com/80/v2-ef2b986f6cbdd5752e1bc2c299809dc1_720w.jpg" data-caption="" data-size="normal" data-rawwidth="550" data-rawheight="201" class="origin_image zh-lightbox-thumb lazy" width="550" data-original="https://pic2.zhimg.com/v2-ef2b986f6cbdd5752e1bc2c299809dc1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ef2b986f6cbdd5752e1bc2c299809dc1_b.jpg" /></p>
<ul><li data-pid="F3-9GeN5">ci2vel=Wingchord divided (by) 2 * velocity=机翼弦长/两倍速度</li></ul>

<h3>SIDE 轴</h3>

<ul>
<li data-pid="yge4zZDr">beta-rad=sideslip angle=侧滑角</li>
<li data-pid="L7Q2U3HJ">aileron-pos-rad=副翼偏转角</li>
<li data-pid="QYoFcZad">rudder-pos-rad=舵偏转角</li>
<li data-pid="zIJC_xRI">bi2vel=Wingspan divided (by) 2 * velocity=翼展/两倍速度</li>
<li data-pid="MadI6TCq">p-aero-rad_sec=（考虑空速的）滚转角速度，如上图</li>
<li data-pid="u3paA2ha">r-aero-rad_sec=（考虑空速的）侧滑角速度，如上图</li>
</ul>

<h3>LIFT 轴 PITCH 轴 YAW 轴</h3>

<ul>
<li data-pid="pSgJeMYg">bw-ft=wingspan</li>
<li data-pid="-CD1hzhi">cbarw-ft= <span class="ztext-math" data-eeimg="1" data-tex="\bar{c}_w">\bar{c}_w</span> =mean aerodynamic chord=MAC=平均气动弦长</li>
</ul>

<p data-pid="YGTyT9qu">新的变量越来越少了，直接把这些轴写一起了。配置文件的解析就到此为止，下一步我们准备开始编写能够加载这些配置文件和进行动力学运算的程序。顺便说一下，如果一个变量在google上也搜不到的话，不妨尝试对jsbsim源码进行全局搜索，多少能找到一点蛛丝马迹，比如bi2vel系列，就是这么找到的：</p>

<p><img src="https://pic4.zhimg.com/80/v2-18a86d1c224d2a01134308d9608c30ff_720w.jpg" data-caption="" data-size="normal" data-rawwidth="782" data-rawheight="244" class="origin_image zh-lightbox-thumb lazy" width="782" data-original="https://pic4.zhimg.com/v2-18a86d1c224d2a01134308d9608c30ff_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-18a86d1c224d2a01134308d9608c30ff_b.jpg" /></p>
<p></p>]]></content><author><name></name></author><category term="unity" /><summary type="html"><![CDATA[jsbsim是一个开源的飞行力学仿真软件，学习它的主要目的是希望能够实现一个类似IL2/1战争雷霆这样的空战游戏。虽然jsbsim能够通过socket通信直接进行调用，但是考虑到调用/打包的问题，以及二次开发的目的，决定还是在unity中使用C#实现一个简化版的气动仿真模型。最终的模型应当能够以飞行器当前状态为输入，输出6个自由度上的力/力矩，接入unity刚体组件。 以jsbsim自带的f-16模型配置文件 f16.xml为例，我们来看看里面都写了什么。 看一下xml根节点，对于实现一个简化版仿真模型来说，metrics,mass_balance,aerodynamics看起来比较重要。其他的地面互动、推力以及自动控制暂时先不看了 。顺便说一句，jsbsim最早的侧重点就是进行自动控制策略的仿真，所以flight_control还是挺详细的，但是这个还是先不和气动力学模块混在一起看了。 实际上，写这篇文章的动机主要就是把配置文件里的缩写含义都搞清楚，以便后续查找。因为里面的缩写很多都是不当人级别的，实乃一大恶习；另一大恶习就是jsbsim中大量实用英制单位（imperial帝国主义单位 ），我们社会主义的花朵看不到SI单位实在很烦躁。 metrics 节点 先来看看metrics，它描述了飞行器的几个尺寸/位置指标 wingarea=翼面积，单位 FT2=feet^2=平方英尺 wingspan 翼展，单位 FT=feet=平方英尺 chord 机翼弦长 htailarea=horizontal tail area=水平尾翼面积 htailarm=水平尾翼力臂（相对气动中心AERORP/CG） vtailarea=vertical tail area=垂直尾翼面积 vtailarm=垂直尾翼力臂 AERORP=aerodynamic reference point=气动参考点，单位 IN=inch=英寸 EYEPOINT=飞行员视角位置 VRP=visual reference point=视觉参考点 我们看到了很多长度、面积、位置信息，在此需要补充一下jsbsim中的坐标系约定。其中所谓VRP就是下图中的一段偏移量，用来确定飞行器“鼻尖”和建模时使用的坐标原点之间的位置关系。 mass_balance节点 mass_balance描述了飞行器的质量分布参数，梦回理论力学 ixx, iyy, izz, ixy, ixz, iyz=构成刚体惯性张量的六个参数，单位 SLUG*FT2，其中slug是一个质量单位 emptywt=empty weight=空载重量，单位 LBS=Libra pondo=磅 CG=center of gravity=重心 Pilot=飞行员，POINTMASS=质点 这里面大概就惯性张量比较难懂了，但是不用害怕，就算啥也不会直接灌倒unity的刚体组件里就行了。平面转动的惯量比较好理解，三维情况比较麻烦的一点就是刚体角动量与瞬时角速度一般方向不同，简单来说，根据质量分布的参数我们可以推断出飞行器在力矩作用下将会如何旋转。 aerodynamics节点 这是要分析的重点数据，内容也很多，已经不能全部展开看了，看一下它的子节点吧 kCLge=k lift coefficient (by) ground effect=升力系数由于地面效应产生的变化 h_b-mac-ft=height-mean aerodynamic chord-feet 除了一个比较出戏的地面效应函数，其他六项（axis=轴）很好理解，分别对应了沿x，y，z轴平动、绕x，y，z轴转动这六个刚体运动自由度。aerodynamics节点里面包含了大量的表格，需要注意jsbsim的实现中各种非线性的公式/函数都是靠查表完成的，并且采用线性插值（没找到二/三维表格是如何插值的，姑且当作双/三线性插值）。 DRAG 轴 CDDh=drag coefficient (by) horizontal deflection=水平尾翼偏转的阻力 qbar-psf=\bar{q}=filght dynamic pressure=空气动压，单位 psf=pounds per square foot=磅力/平方英尺 Sw-sqft=S_W=Wing area=翼面积，单位 sqft=squre foot=平方英尺 alpha-rad=\alpha=angle of attack=攻角，单位=radians=弧度 elevator-pos-rad=升降舵角度 jsbsim里面的函数大部分都是乘积与查表，并且函数也自带description能够比较清晰地描述其用途，后面就不重复讨论了，只把函数、变量的缩写和物理含义写下来。 mach=马赫数 lef-pos-rad=leading edge flap position=前缘缝翼角度 flapreon-mix-rad=襟副翼混合角度？ gear-pos-norm=起落架位置，单位 norm=normalized=归一化（的值，0~1） speedbrake-pos-rad=减速板角度 q-aero-rad_sec=（考虑了空速的）俯仰角速度，p,q,e三个角速度的定义如下图： ci2vel=Wingchord divided (by) 2 * velocity=机翼弦长/两倍速度 SIDE 轴 beta-rad=sideslip angle=侧滑角 aileron-pos-rad=副翼偏转角 rudder-pos-rad=舵偏转角 bi2vel=Wingspan divided (by) 2 * velocity=翼展/两倍速度 p-aero-rad_sec=（考虑空速的）滚转角速度，如上图 r-aero-rad_sec=（考虑空速的）侧滑角速度，如上图 LIFT 轴 PITCH 轴 YAW 轴 bw-ft=wingspan cbarw-ft= \bar{c}_w =mean aerodynamic chord=MAC=平均气动弦长 新的变量越来越少了，直接把这些轴写一起了。配置文件的解析就到此为止，下一步我们准备开始编写能够加载这些配置文件和进行动力学运算的程序。顺便说一下，如果一个变量在google上也搜不到的话，不妨尝试对jsbsim源码进行全局搜索，多少能找到一点蛛丝马迹，比如bi2vel系列，就是这么找到的：]]></summary></entry><entry><title type="html">go语言闭包问题一例——循环变量引用捕获</title><link href="/golang/2020/05/31/problem-of-go-closure.html" rel="alternate" type="text/html" title="go语言闭包问题一例——循环变量引用捕获" /><published>2020-05-31T13:43:00+08:00</published><updated>2020-05-31T13:43:00+08:00</updated><id>/golang/2020/05/31/problem-of-go-closure</id><content type="html" xml:base="/golang/2020/05/31/problem-of-go-closure.html"><![CDATA[<p>刚学习go语言时，其官方文档中就介绍了一种常见的迷惑现象，即 <a href="https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables">Using goroutines on loop iterator variables</a>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"i=%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>
<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">100</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
</code></pre></div></div>

<p>以上程序会输出如下结果而不是第一眼看上去应该得到的 <code class="language-plaintext highlighter-rouge">i=0，1，2，3，4</code></p>

<pre><code class="language-plain">» go run ./test.go
i=5
i=5
i=5
i=5
i=5
</code></pre>

<p>最显然的一个原因当然是go语言的闭包是通过引用捕获 (capture by reference) 自由变量的，即匿名函数中的<code class="language-plaintext highlighter-rouge">i</code>是对循环变量<code class="language-plaintext highlighter-rouge">i</code>的引用，所以当循环结束，程序在<code class="language-plaintext highlighter-rouge">time.Sleep</code>调度协程运行时，5个协程都会得到同一个值<code class="language-plaintext highlighter-rouge">i=5</code>。但是这个锅真的只是引用捕获来背吗？我认为另一个造成迷惑的原因是 GC，因为有了 GC，引用捕获悄悄的延长了循环变量<code class="language-plaintext highlighter-rouge">i</code>的生存时间/scope。上述代码实际上是在循环之外使用了循环变量，而没有任何错误提示！因此 lexical scope + capture by reference 造成了 dynamic scope 的错觉。</p>

<p>为了更好地论证这个观点，下面拿 C++ 举几个例子，毕竟 C++ 的闭包是可以显式指定 capture by reference 还是 capture by value 的</p>

<p>使用 capture by value <code class="language-plaintext highlighter-rouge">[=]</code> 时，输出和预期一样。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i="</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span>
            <span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">fut</span><span class="o">:</span> <span class="n">futures</span><span class="p">){</span>
    <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<pre><code class="language-plain">i=0
i=1
i=2
i=3
i=4
</code></pre>

<p>使用 capture by reference <code class="language-plaintext highlighter-rouge">[&amp;]</code> 时</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i="</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span>
            <span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">fut</span><span class="o">:</span> <span class="n">futures</span><span class="p">){</span>
    <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出…</p>

<pre><code class="language-plain">i=5
i=5
i=5
i=5
i=5
</code></pre>

<p>嗯？居然和 go 的问题一样，没有报错？稍微修改一下调用方式：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">capRefDangle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">futures</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i="</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
                <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span>
                <span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>
<span class="n">capRefDangle</span><span class="p">(</span><span class="n">futures</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">fut</span><span class="o">:</span> <span class="n">futures</span><span class="p">){</span>
    <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出…</p>

<pre><code class="language-plain">i=32766
i=32766
i=32766
i=32766
i=32766
</code></pre>

<p>得到了更奇怪的结果，我本来想说如果是 C++ 就不会存在这种问题，对 dangling reference 一定会报错，然鹅根据实验结果和查询得知这是一种未定义行为，既能得到 go 中一样的结果，也可能输出奇怪的东西，不过总的来说我认为 go 这个锅就是让 capture by reference + GC 背。</p>]]></content><author><name></name></author><category term="golang" /><summary type="html"><![CDATA[刚学习go语言时，其官方文档中就介绍了一种常见的迷惑现象，即 Using goroutines on loop iterator variables:]]></summary></entry><entry><title type="html">如何找回ssh公钥？</title><link href="/linux/2020/05/31/how-to-find-back-ssh-public-key.html" rel="alternate" type="text/html" title="如何找回ssh公钥？" /><published>2020-05-31T00:19:01+08:00</published><updated>2020-05-31T00:19:01+08:00</updated><id>/linux/2020/05/31/how-to-find-back-ssh-public-key</id><content type="html" xml:base="/linux/2020/05/31/how-to-find-back-ssh-public-key.html"><![CDATA[<h2 id="公钥怎么没了">公钥怎么没了</h2>
<p>为什么需要找回公钥呢？因为干了一件蠢事，因为ssh登陆服务器懒得输入密码，就准备把本机公钥<code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa.pub</code>添加到服务器的授权密钥<code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code>里去，结果因为是临时随便搜的方法，拷贝的时候用的这个命令：<code class="language-plaintext highlighter-rouge">scp ~/.ssh/id_rsa.pub 登录用户名@服务器域名:～/.ssh/</code>，按下回车我就后悔了，这不是把服务器的公钥覆盖了么。赶紧测试一下是不是这样，比如<a href="http://github.com">Github</a>一般都是设置ssh key登陆账号的，测试连接：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh <span class="nt">-T</span> git@github.com
git@github.com: Permission denied <span class="o">(</span>publickey<span class="o">)</span><span class="nb">.</span>
</code></pre></div></div>

<p>果然出事了。</p>

<h2 id="找回ssh公钥">找回ssh公钥</h2>
<p>意外的简单：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh-keygen <span class="nt">-y</span> <span class="nt">-f</span> ~/.ssh/id_rsa <span class="o">&gt;</span> ~/.ssh/id_rsa.pub
</code></pre></div></div>

<p>注意这样生成的公钥是没有注释的，一般在后面补上 空格+用户名@主机名 更好。</p>

<h2 id="为什么能找回公钥">为什么能找回公钥</h2>
<p>之前我还在担心无法找回，毕竟记得rsa是个对称的加密算法，能从私钥找回公钥岂不是反向也可？
赶紧补补课，比较重要的点是这几个：</p>
<ul>
  <li>什么是公钥？两个数(n, e)</li>
  <li>私钥？两个数(n, d)</li>
  <li>n=p*q 是一个不容易分解的大质数</li>
  <li>d⋅e ≡ 1 (mod λ(n)) d和e互为模λ(n)的逆，λ(n) 是 Carmichael’s totient function</li>
  <li>没有分解出n的情况下λ(n)难以求解，反之已知p和q时则λ(n) = lcm(p − 1, q − 1)，求个最大公因数即可。</li>
</ul>

<p>所以，光有公钥或私钥都是不能直接计算出对方的，而rsa加密初始计算完成后只需要保留公钥私钥。但是，本机上在文件<code class="language-plaintext highlighter-rouge">id_rsa</code>其实保存了私钥公钥和生成密钥时的其他所有数据，用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>~/.ssh<span class="nv">$ </span>openssl rsa <span class="nt">-text</span> <span class="nt">-noout</span> &lt; id_rsa
</code></pre></div></div>

<p>就能方便地查看，其中就有modulus，publicExponent，privateExponent，prime1，prime2等等，对应于n, e, d, p, q。而且通常来说公钥都是固定的一个数字65537 (0x10001)，所以找回公钥非常方便。</p>]]></content><author><name></name></author><category term="linux" /><summary type="html"><![CDATA[公钥怎么没了 为什么需要找回公钥呢？因为干了一件蠢事，因为ssh登陆服务器懒得输入密码，就准备把本机公钥~/.ssh/id_rsa.pub添加到服务器的授权密钥~/.ssh/authorized_keys里去，结果因为是临时随便搜的方法，拷贝的时候用的这个命令：scp ~/.ssh/id_rsa.pub 登录用户名@服务器域名:～/.ssh/，按下回车我就后悔了，这不是把服务器的公钥覆盖了么。赶紧测试一下是不是这样，比如Github一般都是设置ssh key登陆账号的，测试连接：]]></summary></entry></feed>